// Code generated by protoc-gen-go.
// source: protos/golang.conradwood.net/apis/autodeployer/autodeployer.proto
// DO NOT EDIT!

/*
Package autodeployer is a generated protocol buffer package.

It is generated from these files:
	protos/golang.conradwood.net/apis/autodeployer/autodeployer.proto

It has these top-level messages:
	DeployRequest
	DeployInfo
	DeployResponse
	EmptyResponse
	TerminationRequest
	StartedRequest
	StartupRequest
	StartupResponse
	ResourceRequest
	ResourceResponse
	InfoRequest
	DeployedApp
	InfoResponse
	UndeployRequest
	UndeployResponse
	MachineInfoRequest
	MachineInfoResponse
	URLRequest
	URLResponse
	PackageInstallRequest
	PackageInstallResponse
	StopRequest
	StopResponse
	RedeployInfo
	RedeployInfoList
	BinaryDownload
*/
package autodeployer

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import deploymonkey "golang.conradwood.net/apis/deploymonkey"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type DeploymentStatus int32

const (
	// nothing happened yet
	DeploymentStatus_PREPARING DeploymentStatus = 0
	// forked, exec'ed, waiting for startup message
	DeploymentStatus_STARTING DeploymentStatus = 1
	// downloading binaries
	DeploymentStatus_DOWNLOADING DeploymentStatus = 2
	// gathering resources (e.g. ports)
	DeploymentStatus_RESOURCING DeploymentStatus = 3
	// startup message done, handed control to application
	DeploymentStatus_EXECUSER   DeploymentStatus = 4
	DeploymentStatus_TERMINATED DeploymentStatus = 5
	// not downloading, starting from cache
	DeploymentStatus_CACHEDSTART DeploymentStatus = 6
	// this is being shutdown (but not quite yet TERMINATED). the only transition from STOPPING is to TERMINATED.
	DeploymentStatus_STOPPING DeploymentStatus = 7
)

var DeploymentStatus_name = map[int32]string{
	0: "PREPARING",
	1: "STARTING",
	2: "DOWNLOADING",
	3: "RESOURCING",
	4: "EXECUSER",
	5: "TERMINATED",
	6: "CACHEDSTART",
	7: "STOPPING",
}
var DeploymentStatus_value = map[string]int32{
	"PREPARING":   0,
	"STARTING":    1,
	"DOWNLOADING": 2,
	"RESOURCING":  3,
	"EXECUSER":    4,
	"TERMINATED":  5,
	"CACHEDSTART": 6,
	"STOPPING":    7,
}

func (x DeploymentStatus) String() string {
	return proto.EnumName(DeploymentStatus_name, int32(x))
}
func (DeploymentStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// sent to autodeployer to tell it to deploy something
type DeployRequest struct {
	DownloadURL      string   `protobuf:"bytes,1,opt,name=DownloadURL" json:"DownloadURL,omitempty"`
	DownloadUser     string   `protobuf:"bytes,2,opt,name=DownloadUser" json:"DownloadUser,omitempty"`
	DownloadPassword string   `protobuf:"bytes,3,opt,name=DownloadPassword" json:"DownloadPassword,omitempty"`
	Binary           string   `protobuf:"bytes,4,opt,name=Binary" json:"Binary,omitempty"`
	Args             []string `protobuf:"bytes,5,rep,name=Args" json:"Args,omitempty"`
	//  string Repository = 6;
	BuildID uint64 `protobuf:"varint,7,opt,name=BuildID" json:"BuildID,omitempty"`
	// an opaque id -> will be also returned in InfoResponse
	DeploymentID     string                           `protobuf:"bytes,8,opt,name=DeploymentID" json:"DeploymentID,omitempty"`
	Namespace        string                           `protobuf:"bytes,9,opt,name=Namespace" json:"Namespace,omitempty"`
	Groupname        string                           `protobuf:"bytes,10,opt,name=Groupname" json:"Groupname,omitempty"`
	AutoRegistration []*deploymonkey.AutoRegistration `protobuf:"bytes,11,rep,name=AutoRegistration" json:"AutoRegistration,omitempty"`
	DeployType       string                           `protobuf:"bytes,12,opt,name=DeployType" json:"DeployType,omitempty"`
	StaticTargetDir  string                           `protobuf:"bytes,13,opt,name=StaticTargetDir" json:"StaticTargetDir,omitempty"`
	Public           bool                             `protobuf:"varint,14,opt,name=Public" json:"Public,omitempty"`
	Limits           *deploymonkey.Limits             `protobuf:"bytes,15,opt,name=Limits" json:"Limits,omitempty"`
	AppReference     *deploymonkey.AppReference       `protobuf:"bytes,16,opt,name=AppReference" json:"AppReference,omitempty"`
	RepositoryID     uint64                           `protobuf:"varint,17,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	Deployer         string                           `protobuf:"bytes,18,opt,name=Deployer" json:"Deployer,omitempty"`
	DeployerInfo     []byte                           `protobuf:"bytes,19,opt,name=DeployerInfo,proto3" json:"DeployerInfo,omitempty"`
}

func (m *DeployRequest) Reset()                    { *m = DeployRequest{} }
func (m *DeployRequest) String() string            { return proto.CompactTextString(m) }
func (*DeployRequest) ProtoMessage()               {}
func (*DeployRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *DeployRequest) GetDownloadURL() string {
	if m != nil {
		return m.DownloadURL
	}
	return ""
}

func (m *DeployRequest) GetDownloadUser() string {
	if m != nil {
		return m.DownloadUser
	}
	return ""
}

func (m *DeployRequest) GetDownloadPassword() string {
	if m != nil {
		return m.DownloadPassword
	}
	return ""
}

func (m *DeployRequest) GetBinary() string {
	if m != nil {
		return m.Binary
	}
	return ""
}

func (m *DeployRequest) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *DeployRequest) GetBuildID() uint64 {
	if m != nil {
		return m.BuildID
	}
	return 0
}

func (m *DeployRequest) GetDeploymentID() string {
	if m != nil {
		return m.DeploymentID
	}
	return ""
}

func (m *DeployRequest) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *DeployRequest) GetGroupname() string {
	if m != nil {
		return m.Groupname
	}
	return ""
}

func (m *DeployRequest) GetAutoRegistration() []*deploymonkey.AutoRegistration {
	if m != nil {
		return m.AutoRegistration
	}
	return nil
}

func (m *DeployRequest) GetDeployType() string {
	if m != nil {
		return m.DeployType
	}
	return ""
}

func (m *DeployRequest) GetStaticTargetDir() string {
	if m != nil {
		return m.StaticTargetDir
	}
	return ""
}

func (m *DeployRequest) GetPublic() bool {
	if m != nil {
		return m.Public
	}
	return false
}

func (m *DeployRequest) GetLimits() *deploymonkey.Limits {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *DeployRequest) GetAppReference() *deploymonkey.AppReference {
	if m != nil {
		return m.AppReference
	}
	return nil
}

func (m *DeployRequest) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *DeployRequest) GetDeployer() string {
	if m != nil {
		return m.Deployer
	}
	return ""
}

func (m *DeployRequest) GetDeployerInfo() []byte {
	if m != nil {
		return m.DeployerInfo
	}
	return nil
}

// this entire message is deprecated and obsolete. see deployedapp instead. However this is used in many places in the registry, so it cannot be removed (yet) and still has to be handled correctly */
type DeployInfo struct {
	DownloadURL      string   `protobuf:"bytes,1,opt,name=DownloadURL" json:"DownloadURL,omitempty"`
	DownloadUser     string   `protobuf:"bytes,2,opt,name=DownloadUser" json:"DownloadUser,omitempty"`
	DownloadPassword string   `protobuf:"bytes,3,opt,name=DownloadPassword" json:"DownloadPassword,omitempty"`
	Binary           string   `protobuf:"bytes,4,opt,name=Binary" json:"Binary,omitempty"`
	Args             []string `protobuf:"bytes,5,rep,name=Args" json:"Args,omitempty"`
	// string Repository = 6;
	BuildID uint64 `protobuf:"varint,7,opt,name=BuildID" json:"BuildID,omitempty"`
	// an opaque id -> will be also returned in InfoResponse
	DeploymentID     string                           `protobuf:"bytes,8,opt,name=DeploymentID" json:"DeploymentID,omitempty"`
	Namespace        string                           `protobuf:"bytes,9,opt,name=Namespace" json:"Namespace,omitempty"`
	Groupname        string                           `protobuf:"bytes,10,opt,name=Groupname" json:"Groupname,omitempty"`
	AutoRegistration []*deploymonkey.AutoRegistration `protobuf:"bytes,11,rep,name=AutoRegistration" json:"AutoRegistration,omitempty"`
	DeployType       string                           `protobuf:"bytes,12,opt,name=DeployType" json:"DeployType,omitempty"`
	StaticTargetDir  string                           `protobuf:"bytes,13,opt,name=StaticTargetDir" json:"StaticTargetDir,omitempty"`
	Public           bool                             `protobuf:"varint,14,opt,name=Public" json:"Public,omitempty"`
	Ports            []uint32                         `protobuf:"varint,15,rep,packed,name=Ports" json:"Ports,omitempty"`
	Deploymentpath   string                           `protobuf:"bytes,16,opt,name=Deploymentpath" json:"Deploymentpath,omitempty"`
	Status           DeploymentStatus                 `protobuf:"varint,17,opt,name=Status,enum=autodeployer.DeploymentStatus" json:"Status,omitempty"`
	RuntimeSeconds   uint64                           `protobuf:"varint,18,opt,name=RuntimeSeconds" json:"RuntimeSeconds,omitempty"`
	AppReference     *deploymonkey.AppReference       `protobuf:"bytes,19,opt,name=AppReference" json:"AppReference,omitempty"`
	RepositoryID     uint64                           `protobuf:"varint,20,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	ResolvedArgs     []string                         `protobuf:"bytes,21,rep,name=ResolvedArgs" json:"ResolvedArgs,omitempty"`
	Pid              uint64                           `protobuf:"varint,22,opt,name=Pid" json:"Pid,omitempty"`
	ChildPids        []uint64                         `protobuf:"varint,23,rep,packed,name=ChildPids" json:"ChildPids,omitempty"`
	UserID           string                           `protobuf:"bytes,24,opt,name=UserID" json:"UserID,omitempty"`
	UserName         string                           `protobuf:"bytes,25,opt,name=UserName" json:"UserName,omitempty"`
	GroupID          string                           `protobuf:"bytes,26,opt,name=GroupID" json:"GroupID,omitempty"`
}

func (m *DeployInfo) Reset()                    { *m = DeployInfo{} }
func (m *DeployInfo) String() string            { return proto.CompactTextString(m) }
func (*DeployInfo) ProtoMessage()               {}
func (*DeployInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *DeployInfo) GetDownloadURL() string {
	if m != nil {
		return m.DownloadURL
	}
	return ""
}

func (m *DeployInfo) GetDownloadUser() string {
	if m != nil {
		return m.DownloadUser
	}
	return ""
}

func (m *DeployInfo) GetDownloadPassword() string {
	if m != nil {
		return m.DownloadPassword
	}
	return ""
}

func (m *DeployInfo) GetBinary() string {
	if m != nil {
		return m.Binary
	}
	return ""
}

func (m *DeployInfo) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *DeployInfo) GetBuildID() uint64 {
	if m != nil {
		return m.BuildID
	}
	return 0
}

func (m *DeployInfo) GetDeploymentID() string {
	if m != nil {
		return m.DeploymentID
	}
	return ""
}

func (m *DeployInfo) GetNamespace() string {
	if m != nil {
		return m.Namespace
	}
	return ""
}

func (m *DeployInfo) GetGroupname() string {
	if m != nil {
		return m.Groupname
	}
	return ""
}

func (m *DeployInfo) GetAutoRegistration() []*deploymonkey.AutoRegistration {
	if m != nil {
		return m.AutoRegistration
	}
	return nil
}

func (m *DeployInfo) GetDeployType() string {
	if m != nil {
		return m.DeployType
	}
	return ""
}

func (m *DeployInfo) GetStaticTargetDir() string {
	if m != nil {
		return m.StaticTargetDir
	}
	return ""
}

func (m *DeployInfo) GetPublic() bool {
	if m != nil {
		return m.Public
	}
	return false
}

func (m *DeployInfo) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *DeployInfo) GetDeploymentpath() string {
	if m != nil {
		return m.Deploymentpath
	}
	return ""
}

func (m *DeployInfo) GetStatus() DeploymentStatus {
	if m != nil {
		return m.Status
	}
	return DeploymentStatus_PREPARING
}

func (m *DeployInfo) GetRuntimeSeconds() uint64 {
	if m != nil {
		return m.RuntimeSeconds
	}
	return 0
}

func (m *DeployInfo) GetAppReference() *deploymonkey.AppReference {
	if m != nil {
		return m.AppReference
	}
	return nil
}

func (m *DeployInfo) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *DeployInfo) GetResolvedArgs() []string {
	if m != nil {
		return m.ResolvedArgs
	}
	return nil
}

func (m *DeployInfo) GetPid() uint64 {
	if m != nil {
		return m.Pid
	}
	return 0
}

func (m *DeployInfo) GetChildPids() []uint64 {
	if m != nil {
		return m.ChildPids
	}
	return nil
}

func (m *DeployInfo) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *DeployInfo) GetUserName() string {
	if m != nil {
		return m.UserName
	}
	return ""
}

func (m *DeployInfo) GetGroupID() string {
	if m != nil {
		return m.GroupID
	}
	return ""
}

type DeployResponse struct {
	// did it succeed in starting and running?
	Success bool `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
	// does it remain running (might be a very shortlived application)
	Running bool `protobuf:"varint,2,opt,name=Running" json:"Running,omitempty"`
	// any messages?
	Message string `protobuf:"bytes,3,opt,name=Message" json:"Message,omitempty"`
	// the local ports chosen for the application
	Ports []uint32 `protobuf:"varint,4,rep,packed,name=Ports" json:"Ports,omitempty"`
	// the user this application runs as
	UserID string `protobuf:"bytes,5,opt,name=UserID" json:"UserID,omitempty"`
	// an ID unique to this instance
	ID string `protobuf:"bytes,6,opt,name=ID" json:"ID,omitempty"`
}

func (m *DeployResponse) Reset()                    { *m = DeployResponse{} }
func (m *DeployResponse) String() string            { return proto.CompactTextString(m) }
func (*DeployResponse) ProtoMessage()               {}
func (*DeployResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *DeployResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *DeployResponse) GetRunning() bool {
	if m != nil {
		return m.Running
	}
	return false
}

func (m *DeployResponse) GetMessage() string {
	if m != nil {
		return m.Message
	}
	return ""
}

func (m *DeployResponse) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *DeployResponse) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *DeployResponse) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

type EmptyResponse struct {
}

func (m *EmptyResponse) Reset()                    { *m = EmptyResponse{} }
func (m *EmptyResponse) String() string            { return proto.CompactTextString(m) }
func (*EmptyResponse) ProtoMessage()               {}
func (*EmptyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type TerminationRequest struct {
	Msgid  string `protobuf:"bytes,1,opt,name=Msgid" json:"Msgid,omitempty"`
	Failed bool   `protobuf:"varint,2,opt,name=Failed" json:"Failed,omitempty"`
}

func (m *TerminationRequest) Reset()                    { *m = TerminationRequest{} }
func (m *TerminationRequest) String() string            { return proto.CompactTextString(m) }
func (*TerminationRequest) ProtoMessage()               {}
func (*TerminationRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *TerminationRequest) GetMsgid() string {
	if m != nil {
		return m.Msgid
	}
	return ""
}

func (m *TerminationRequest) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

type StartedRequest struct {
	Msgid          string   `protobuf:"bytes,1,opt,name=Msgid" json:"Msgid,omitempty"`
	DownloadFailed bool     `protobuf:"varint,2,opt,name=DownloadFailed" json:"DownloadFailed,omitempty"`
	Args           []string `protobuf:"bytes,3,rep,name=Args" json:"Args,omitempty"`
}

func (m *StartedRequest) Reset()                    { *m = StartedRequest{} }
func (m *StartedRequest) String() string            { return proto.CompactTextString(m) }
func (*StartedRequest) ProtoMessage()               {}
func (*StartedRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *StartedRequest) GetMsgid() string {
	if m != nil {
		return m.Msgid
	}
	return ""
}

func (m *StartedRequest) GetDownloadFailed() bool {
	if m != nil {
		return m.DownloadFailed
	}
	return false
}

func (m *StartedRequest) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

// sent by autodeployer_starter to itself
type StartupRequest struct {
	Msgid string `protobuf:"bytes,1,opt,name=Msgid" json:"Msgid,omitempty"`
	PID   uint64 `protobuf:"varint,2,opt,name=PID" json:"PID,omitempty"`
}

func (m *StartupRequest) Reset()                    { *m = StartupRequest{} }
func (m *StartupRequest) String() string            { return proto.CompactTextString(m) }
func (*StartupRequest) ProtoMessage()               {}
func (*StartupRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *StartupRequest) GetMsgid() string {
	if m != nil {
		return m.Msgid
	}
	return ""
}

func (m *StartupRequest) GetPID() uint64 {
	if m != nil {
		return m.PID
	}
	return 0
}

// sent by autodeployer to its _starter
type StartupResponse struct {
	URL              string   `protobuf:"bytes,1,opt,name=URL" json:"URL,omitempty"`
	DownloadUser     string   `protobuf:"bytes,2,opt,name=DownloadUser" json:"DownloadUser,omitempty"`
	DownloadPassword string   `protobuf:"bytes,3,opt,name=DownloadPassword" json:"DownloadPassword,omitempty"`
	Binary           string   `protobuf:"bytes,4,opt,name=Binary" json:"Binary,omitempty"`
	Args             []string `protobuf:"bytes,5,rep,name=Args" json:"Args,omitempty"`
	WorkingDir       string   `protobuf:"bytes,6,opt,name=WorkingDir" json:"WorkingDir,omitempty"`
	// max resource limits for the process before it's killed
	Limits       *deploymonkey.Limits       `protobuf:"bytes,7,opt,name=Limits" json:"Limits,omitempty"`
	SecureArgs   map[string]string          `protobuf:"bytes,8,rep,name=SecureArgs" json:"SecureArgs,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	AppReference *deploymonkey.AppReference `protobuf:"bytes,9,opt,name=AppReference" json:"AppReference,omitempty"`
	// internal temporary flag. if true starter.go will execute SetRLimit to limit memory. if false it will do no such thing
	// eventually we migrate fully to cgroups and then this will be irrelevant
	UseSetRLimit bool `protobuf:"varint,10,opt,name=UseSetRLimit" json:"UseSetRLimit,omitempty"`
}

func (m *StartupResponse) Reset()                    { *m = StartupResponse{} }
func (m *StartupResponse) String() string            { return proto.CompactTextString(m) }
func (*StartupResponse) ProtoMessage()               {}
func (*StartupResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *StartupResponse) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *StartupResponse) GetDownloadUser() string {
	if m != nil {
		return m.DownloadUser
	}
	return ""
}

func (m *StartupResponse) GetDownloadPassword() string {
	if m != nil {
		return m.DownloadPassword
	}
	return ""
}

func (m *StartupResponse) GetBinary() string {
	if m != nil {
		return m.Binary
	}
	return ""
}

func (m *StartupResponse) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *StartupResponse) GetWorkingDir() string {
	if m != nil {
		return m.WorkingDir
	}
	return ""
}

func (m *StartupResponse) GetLimits() *deploymonkey.Limits {
	if m != nil {
		return m.Limits
	}
	return nil
}

func (m *StartupResponse) GetSecureArgs() map[string]string {
	if m != nil {
		return m.SecureArgs
	}
	return nil
}

func (m *StartupResponse) GetAppReference() *deploymonkey.AppReference {
	if m != nil {
		return m.AppReference
	}
	return nil
}

func (m *StartupResponse) GetUseSetRLimit() bool {
	if m != nil {
		return m.UseSetRLimit
	}
	return false
}

// sent by the starter once download completed
type ResourceRequest struct {
	Msgid string `protobuf:"bytes,1,opt,name=Msgid" json:"Msgid,omitempty"`
	Ports int32  `protobuf:"varint,2,opt,name=Ports" json:"Ports,omitempty"`
}

func (m *ResourceRequest) Reset()                    { *m = ResourceRequest{} }
func (m *ResourceRequest) String() string            { return proto.CompactTextString(m) }
func (*ResourceRequest) ProtoMessage()               {}
func (*ResourceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ResourceRequest) GetMsgid() string {
	if m != nil {
		return m.Msgid
	}
	return ""
}

func (m *ResourceRequest) GetPorts() int32 {
	if m != nil {
		return m.Ports
	}
	return 0
}

// autodeployer sents to starter
type ResourceResponse struct {
	Ports []int32 `protobuf:"varint,1,rep,packed,name=Ports" json:"Ports,omitempty"`
}

func (m *ResourceResponse) Reset()                    { *m = ResourceResponse{} }
func (m *ResourceResponse) String() string            { return proto.CompactTextString(m) }
func (*ResourceResponse) ProtoMessage()               {}
func (*ResourceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ResourceResponse) GetPorts() []int32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

type InfoRequest struct {
	Deployer string `protobuf:"bytes,1,opt,name=Deployer" json:"Deployer,omitempty"`
}

func (m *InfoRequest) Reset()                    { *m = InfoRequest{} }
func (m *InfoRequest) String() string            { return proto.CompactTextString(m) }
func (*InfoRequest) ProtoMessage()               {}
func (*InfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *InfoRequest) GetDeployer() string {
	if m != nil {
		return m.Deployer
	}
	return ""
}

type DeployedApp struct {
	// autodeployer "StartupMsg"
	ID             string           `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Deployment     *DeployInfo      `protobuf:"bytes,2,opt,name=Deployment" json:"Deployment,omitempty"`
	DeployRequest  *DeployRequest   `protobuf:"bytes,3,opt,name=DeployRequest" json:"DeployRequest,omitempty"`
	Ports          []uint32         `protobuf:"varint,4,rep,packed,name=Ports" json:"Ports,omitempty"`
	Status         DeploymentStatus `protobuf:"varint,5,opt,name=Status,enum=autodeployer.DeploymentStatus" json:"Status,omitempty"`
	RuntimeSeconds uint64           `protobuf:"varint,6,opt,name=RuntimeSeconds" json:"RuntimeSeconds,omitempty"`
}

func (m *DeployedApp) Reset()                    { *m = DeployedApp{} }
func (m *DeployedApp) String() string            { return proto.CompactTextString(m) }
func (*DeployedApp) ProtoMessage()               {}
func (*DeployedApp) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *DeployedApp) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *DeployedApp) GetDeployment() *DeployInfo {
	if m != nil {
		return m.Deployment
	}
	return nil
}

func (m *DeployedApp) GetDeployRequest() *DeployRequest {
	if m != nil {
		return m.DeployRequest
	}
	return nil
}

func (m *DeployedApp) GetPorts() []uint32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

func (m *DeployedApp) GetStatus() DeploymentStatus {
	if m != nil {
		return m.Status
	}
	return DeploymentStatus_PREPARING
}

func (m *DeployedApp) GetRuntimeSeconds() uint64 {
	if m != nil {
		return m.RuntimeSeconds
	}
	return 0
}

type InfoResponse struct {
	Apps []*DeployedApp `protobuf:"bytes,1,rep,name=Apps" json:"Apps,omitempty"`
}

func (m *InfoResponse) Reset()                    { *m = InfoResponse{} }
func (m *InfoResponse) String() string            { return proto.CompactTextString(m) }
func (*InfoResponse) ProtoMessage()               {}
func (*InfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *InfoResponse) GetApps() []*DeployedApp {
	if m != nil {
		return m.Apps
	}
	return nil
}

type UndeployRequest struct {
	// this will match on both:
	// the startup message (which is internal to autodeployer) - query it to get one
	// AND the DeploymentID (as was submitted in DeployRequest)
	ID    string `protobuf:"bytes,1,opt,name=ID" json:"ID,omitempty"`
	Block bool   `protobuf:"varint,2,opt,name=Block" json:"Block,omitempty"`
}

func (m *UndeployRequest) Reset()                    { *m = UndeployRequest{} }
func (m *UndeployRequest) String() string            { return proto.CompactTextString(m) }
func (*UndeployRequest) ProtoMessage()               {}
func (*UndeployRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *UndeployRequest) GetID() string {
	if m != nil {
		return m.ID
	}
	return ""
}

func (m *UndeployRequest) GetBlock() bool {
	if m != nil {
		return m.Block
	}
	return false
}

type UndeployResponse struct {
}

func (m *UndeployResponse) Reset()                    { *m = UndeployResponse{} }
func (m *UndeployResponse) String() string            { return proto.CompactTextString(m) }
func (*UndeployResponse) ProtoMessage()               {}
func (*UndeployResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

type MachineInfoRequest struct {
}

func (m *MachineInfoRequest) Reset()                    { *m = MachineInfoRequest{} }
func (m *MachineInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*MachineInfoRequest) ProtoMessage()               {}
func (*MachineInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type MachineInfoResponse struct {
	MachineGroup        []string          `protobuf:"bytes,1,rep,name=MachineGroup" json:"MachineGroup,omitempty"`
	AutoDeployerVersion uint64            `protobuf:"varint,2,opt,name=AutoDeployerVersion" json:"AutoDeployerVersion,omitempty"`
	Stopping            bool              `protobuf:"varint,3,opt,name=Stopping" json:"Stopping,omitempty"`
	AutodeployerBinary  string            `protobuf:"bytes,4,opt,name=AutodeployerBinary" json:"AutodeployerBinary,omitempty"`
	SecondsRunning      uint32            `protobuf:"varint,5,opt,name=SecondsRunning" json:"SecondsRunning,omitempty"`
	InstanceID          string            `protobuf:"bytes,6,opt,name=InstanceID" json:"InstanceID,omitempty"`
	PortsInUse          []uint32          `protobuf:"varint,7,rep,packed,name=PortsInUse" json:"PortsInUse,omitempty"`
	CGroupsInUse        []string          `protobuf:"bytes,8,rep,name=CGroupsInUse" json:"CGroupsInUse,omitempty"`
	PortMappings        map[uint32]uint32 `protobuf:"bytes,9,rep,name=PortMappings" json:"PortMappings,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	UsersInUse          map[string]uint32 `protobuf:"bytes,10,rep,name=UsersInUse" json:"UsersInUse,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *MachineInfoResponse) Reset()                    { *m = MachineInfoResponse{} }
func (m *MachineInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*MachineInfoResponse) ProtoMessage()               {}
func (*MachineInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *MachineInfoResponse) GetMachineGroup() []string {
	if m != nil {
		return m.MachineGroup
	}
	return nil
}

func (m *MachineInfoResponse) GetAutoDeployerVersion() uint64 {
	if m != nil {
		return m.AutoDeployerVersion
	}
	return 0
}

func (m *MachineInfoResponse) GetStopping() bool {
	if m != nil {
		return m.Stopping
	}
	return false
}

func (m *MachineInfoResponse) GetAutodeployerBinary() string {
	if m != nil {
		return m.AutodeployerBinary
	}
	return ""
}

func (m *MachineInfoResponse) GetSecondsRunning() uint32 {
	if m != nil {
		return m.SecondsRunning
	}
	return 0
}

func (m *MachineInfoResponse) GetInstanceID() string {
	if m != nil {
		return m.InstanceID
	}
	return ""
}

func (m *MachineInfoResponse) GetPortsInUse() []uint32 {
	if m != nil {
		return m.PortsInUse
	}
	return nil
}

func (m *MachineInfoResponse) GetCGroupsInUse() []string {
	if m != nil {
		return m.CGroupsInUse
	}
	return nil
}

func (m *MachineInfoResponse) GetPortMappings() map[uint32]uint32 {
	if m != nil {
		return m.PortMappings
	}
	return nil
}

func (m *MachineInfoResponse) GetUsersInUse() map[string]uint32 {
	if m != nil {
		return m.UsersInUse
	}
	return nil
}

type URLRequest struct {
	URL           string `protobuf:"bytes,1,opt,name=URL" json:"URL,omitempty"`
	ForceDownload bool   `protobuf:"varint,2,opt,name=ForceDownload" json:"ForceDownload,omitempty"`
}

func (m *URLRequest) Reset()                    { *m = URLRequest{} }
func (m *URLRequest) String() string            { return proto.CompactTextString(m) }
func (*URLRequest) ProtoMessage()               {}
func (*URLRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *URLRequest) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *URLRequest) GetForceDownload() bool {
	if m != nil {
		return m.ForceDownload
	}
	return false
}

type URLResponse struct {
	URL             string `protobuf:"bytes,1,opt,name=URL" json:"URL,omitempty"`
	BytesDownloaded uint64 `protobuf:"varint,2,opt,name=BytesDownloaded" json:"BytesDownloaded,omitempty"`
	TotalBytes      uint64 `protobuf:"varint,3,opt,name=TotalBytes" json:"TotalBytes,omitempty"`
	CacheDisabled   bool   `protobuf:"varint,4,opt,name=CacheDisabled" json:"CacheDisabled,omitempty"`
}

func (m *URLResponse) Reset()                    { *m = URLResponse{} }
func (m *URLResponse) String() string            { return proto.CompactTextString(m) }
func (*URLResponse) ProtoMessage()               {}
func (*URLResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *URLResponse) GetURL() string {
	if m != nil {
		return m.URL
	}
	return ""
}

func (m *URLResponse) GetBytesDownloaded() uint64 {
	if m != nil {
		return m.BytesDownloaded
	}
	return 0
}

func (m *URLResponse) GetTotalBytes() uint64 {
	if m != nil {
		return m.TotalBytes
	}
	return 0
}

func (m *URLResponse) GetCacheDisabled() bool {
	if m != nil {
		return m.CacheDisabled
	}
	return false
}

type PackageInstallRequest struct {
	Name string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
}

func (m *PackageInstallRequest) Reset()                    { *m = PackageInstallRequest{} }
func (m *PackageInstallRequest) String() string            { return proto.CompactTextString(m) }
func (*PackageInstallRequest) ProtoMessage()               {}
func (*PackageInstallRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *PackageInstallRequest) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PackageInstallResponse struct {
	Name      string `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Installed bool   `protobuf:"varint,2,opt,name=Installed" json:"Installed,omitempty"`
}

func (m *PackageInstallResponse) Reset()                    { *m = PackageInstallResponse{} }
func (m *PackageInstallResponse) String() string            { return proto.CompactTextString(m) }
func (*PackageInstallResponse) ProtoMessage()               {}
func (*PackageInstallResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *PackageInstallResponse) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *PackageInstallResponse) GetInstalled() bool {
	if m != nil {
		return m.Installed
	}
	return false
}

type StopRequest struct {
	IfNotVersion        uint64 `protobuf:"varint,1,opt,name=IfNotVersion" json:"IfNotVersion,omitempty"`
	RedeployOnNextStart bool   `protobuf:"varint,2,opt,name=RedeployOnNextStart" json:"RedeployOnNextStart,omitempty"`
}

func (m *StopRequest) Reset()                    { *m = StopRequest{} }
func (m *StopRequest) String() string            { return proto.CompactTextString(m) }
func (*StopRequest) ProtoMessage()               {}
func (*StopRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *StopRequest) GetIfNotVersion() uint64 {
	if m != nil {
		return m.IfNotVersion
	}
	return 0
}

func (m *StopRequest) GetRedeployOnNextStart() bool {
	if m != nil {
		return m.RedeployOnNextStart
	}
	return false
}

type StopResponse struct {
	Version  uint64 `protobuf:"varint,1,opt,name=Version" json:"Version,omitempty"`
	Stopping bool   `protobuf:"varint,2,opt,name=Stopping" json:"Stopping,omitempty"`
}

func (m *StopResponse) Reset()                    { *m = StopResponse{} }
func (m *StopResponse) String() string            { return proto.CompactTextString(m) }
func (*StopResponse) ProtoMessage()               {}
func (*StopResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *StopResponse) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *StopResponse) GetStopping() bool {
	if m != nil {
		return m.Stopping
	}
	return false
}

type RedeployInfo struct {
	DeployRequest *DeployRequest `protobuf:"bytes,1,opt,name=DeployRequest" json:"DeployRequest,omitempty"`
	Resources     []byte         `protobuf:"bytes,2,opt,name=Resources,proto3" json:"Resources,omitempty"`
}

func (m *RedeployInfo) Reset()                    { *m = RedeployInfo{} }
func (m *RedeployInfo) String() string            { return proto.CompactTextString(m) }
func (*RedeployInfo) ProtoMessage()               {}
func (*RedeployInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *RedeployInfo) GetDeployRequest() *DeployRequest {
	if m != nil {
		return m.DeployRequest
	}
	return nil
}

func (m *RedeployInfo) GetResources() []byte {
	if m != nil {
		return m.Resources
	}
	return nil
}

type RedeployInfoList struct {
	Infos []*RedeployInfo `protobuf:"bytes,1,rep,name=Infos" json:"Infos,omitempty"`
}

func (m *RedeployInfoList) Reset()                    { *m = RedeployInfoList{} }
func (m *RedeployInfoList) String() string            { return proto.CompactTextString(m) }
func (*RedeployInfoList) ProtoMessage()               {}
func (*RedeployInfoList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *RedeployInfoList) GetInfos() []*RedeployInfo {
	if m != nil {
		return m.Infos
	}
	return nil
}

type BinaryDownload struct {
	TargetFilename string `protobuf:"bytes,1,opt,name=TargetFilename" json:"TargetFilename,omitempty"`
	Data           []byte `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *BinaryDownload) Reset()                    { *m = BinaryDownload{} }
func (m *BinaryDownload) String() string            { return proto.CompactTextString(m) }
func (*BinaryDownload) ProtoMessage()               {}
func (*BinaryDownload) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *BinaryDownload) GetTargetFilename() string {
	if m != nil {
		return m.TargetFilename
	}
	return ""
}

func (m *BinaryDownload) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func init() {
	proto.RegisterType((*DeployRequest)(nil), "autodeployer.DeployRequest")
	proto.RegisterType((*DeployInfo)(nil), "autodeployer.DeployInfo")
	proto.RegisterType((*DeployResponse)(nil), "autodeployer.DeployResponse")
	proto.RegisterType((*EmptyResponse)(nil), "autodeployer.EmptyResponse")
	proto.RegisterType((*TerminationRequest)(nil), "autodeployer.TerminationRequest")
	proto.RegisterType((*StartedRequest)(nil), "autodeployer.StartedRequest")
	proto.RegisterType((*StartupRequest)(nil), "autodeployer.StartupRequest")
	proto.RegisterType((*StartupResponse)(nil), "autodeployer.StartupResponse")
	proto.RegisterType((*ResourceRequest)(nil), "autodeployer.ResourceRequest")
	proto.RegisterType((*ResourceResponse)(nil), "autodeployer.ResourceResponse")
	proto.RegisterType((*InfoRequest)(nil), "autodeployer.InfoRequest")
	proto.RegisterType((*DeployedApp)(nil), "autodeployer.DeployedApp")
	proto.RegisterType((*InfoResponse)(nil), "autodeployer.InfoResponse")
	proto.RegisterType((*UndeployRequest)(nil), "autodeployer.UndeployRequest")
	proto.RegisterType((*UndeployResponse)(nil), "autodeployer.UndeployResponse")
	proto.RegisterType((*MachineInfoRequest)(nil), "autodeployer.MachineInfoRequest")
	proto.RegisterType((*MachineInfoResponse)(nil), "autodeployer.MachineInfoResponse")
	proto.RegisterType((*URLRequest)(nil), "autodeployer.URLRequest")
	proto.RegisterType((*URLResponse)(nil), "autodeployer.URLResponse")
	proto.RegisterType((*PackageInstallRequest)(nil), "autodeployer.PackageInstallRequest")
	proto.RegisterType((*PackageInstallResponse)(nil), "autodeployer.PackageInstallResponse")
	proto.RegisterType((*StopRequest)(nil), "autodeployer.StopRequest")
	proto.RegisterType((*StopResponse)(nil), "autodeployer.StopResponse")
	proto.RegisterType((*RedeployInfo)(nil), "autodeployer.RedeployInfo")
	proto.RegisterType((*RedeployInfoList)(nil), "autodeployer.RedeployInfoList")
	proto.RegisterType((*BinaryDownload)(nil), "autodeployer.BinaryDownload")
	proto.RegisterEnum("autodeployer.DeploymentStatus", DeploymentStatus_name, DeploymentStatus_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for AutoDeployer service

type AutoDeployerClient interface {
	// deploy an application
	Deploy(ctx context.Context, in *DeployRequest, opts ...grpc.CallOption) (*DeployResponse, error)
	Undeploy(ctx context.Context, in *UndeployRequest, opts ...grpc.CallOption) (*UndeployResponse, error)
	// once we re-executed ourselves, we send this message to our selves
	InternalStartup(ctx context.Context, in *StartupRequest, opts ...grpc.CallOption) (*StartupResponse, error)
	// sent by the starter to ourselves
	AllocResources(ctx context.Context, in *ResourceRequest, opts ...grpc.CallOption) (*ResourceResponse, error)
	// sent by the starter to ourselves
	Terminated(ctx context.Context, in *TerminationRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// sent by the starter to ourselves
	Started(ctx context.Context, in *StartedRequest, opts ...grpc.CallOption) (*EmptyResponse, error)
	// what's running??
	GetDeployments(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error)
	// what kind of machine are we running on?
	// name/speed/ram/bla
	GetMachineInfo(ctx context.Context, in *MachineInfoRequest, opts ...grpc.CallOption) (*MachineInfoResponse, error)
	// "undo" all actions (so they will be re-evaluated and applied on next scan)
	ClearActions(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error)
	// shutdown autodeployer (this won't send a return message)
	StopAutodeployer(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error)
	// download the "DownloadURL".
	Download(ctx context.Context, in *StartedRequest, opts ...grpc.CallOption) (AutoDeployer_DownloadClient, error)
	// start a download and put it into cache
	CacheURL(ctx context.Context, in *URLRequest, opts ...grpc.CallOption) (*URLResponse, error)
	// install package (Asynchronous)
	InstallPackage(ctx context.Context, in *PackageInstallRequest, opts ...grpc.CallOption) (*PackageInstallResponse, error)
	// check if package is installed
	CheckPackage(ctx context.Context, in *PackageInstallRequest, opts ...grpc.CallOption) (*PackageInstallResponse, error)
}

type autoDeployerClient struct {
	cc *grpc.ClientConn
}

func NewAutoDeployerClient(cc *grpc.ClientConn) AutoDeployerClient {
	return &autoDeployerClient{cc}
}

func (c *autoDeployerClient) Deploy(ctx context.Context, in *DeployRequest, opts ...grpc.CallOption) (*DeployResponse, error) {
	out := new(DeployResponse)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/Deploy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDeployerClient) Undeploy(ctx context.Context, in *UndeployRequest, opts ...grpc.CallOption) (*UndeployResponse, error) {
	out := new(UndeployResponse)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/Undeploy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDeployerClient) InternalStartup(ctx context.Context, in *StartupRequest, opts ...grpc.CallOption) (*StartupResponse, error) {
	out := new(StartupResponse)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/InternalStartup", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDeployerClient) AllocResources(ctx context.Context, in *ResourceRequest, opts ...grpc.CallOption) (*ResourceResponse, error) {
	out := new(ResourceResponse)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/AllocResources", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDeployerClient) Terminated(ctx context.Context, in *TerminationRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/Terminated", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDeployerClient) Started(ctx context.Context, in *StartedRequest, opts ...grpc.CallOption) (*EmptyResponse, error) {
	out := new(EmptyResponse)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/Started", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDeployerClient) GetDeployments(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	out := new(InfoResponse)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/GetDeployments", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDeployerClient) GetMachineInfo(ctx context.Context, in *MachineInfoRequest, opts ...grpc.CallOption) (*MachineInfoResponse, error) {
	out := new(MachineInfoResponse)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/GetMachineInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDeployerClient) ClearActions(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/ClearActions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDeployerClient) StopAutodeployer(ctx context.Context, in *StopRequest, opts ...grpc.CallOption) (*StopResponse, error) {
	out := new(StopResponse)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/StopAutodeployer", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDeployerClient) Download(ctx context.Context, in *StartedRequest, opts ...grpc.CallOption) (AutoDeployer_DownloadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_AutoDeployer_serviceDesc.Streams[0], c.cc, "/autodeployer.AutoDeployer/Download", opts...)
	if err != nil {
		return nil, err
	}
	x := &autoDeployerDownloadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type AutoDeployer_DownloadClient interface {
	Recv() (*BinaryDownload, error)
	grpc.ClientStream
}

type autoDeployerDownloadClient struct {
	grpc.ClientStream
}

func (x *autoDeployerDownloadClient) Recv() (*BinaryDownload, error) {
	m := new(BinaryDownload)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *autoDeployerClient) CacheURL(ctx context.Context, in *URLRequest, opts ...grpc.CallOption) (*URLResponse, error) {
	out := new(URLResponse)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/CacheURL", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDeployerClient) InstallPackage(ctx context.Context, in *PackageInstallRequest, opts ...grpc.CallOption) (*PackageInstallResponse, error) {
	out := new(PackageInstallResponse)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/InstallPackage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *autoDeployerClient) CheckPackage(ctx context.Context, in *PackageInstallRequest, opts ...grpc.CallOption) (*PackageInstallResponse, error) {
	out := new(PackageInstallResponse)
	err := grpc.Invoke(ctx, "/autodeployer.AutoDeployer/CheckPackage", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for AutoDeployer service

type AutoDeployerServer interface {
	// deploy an application
	Deploy(context.Context, *DeployRequest) (*DeployResponse, error)
	Undeploy(context.Context, *UndeployRequest) (*UndeployResponse, error)
	// once we re-executed ourselves, we send this message to our selves
	InternalStartup(context.Context, *StartupRequest) (*StartupResponse, error)
	// sent by the starter to ourselves
	AllocResources(context.Context, *ResourceRequest) (*ResourceResponse, error)
	// sent by the starter to ourselves
	Terminated(context.Context, *TerminationRequest) (*EmptyResponse, error)
	// sent by the starter to ourselves
	Started(context.Context, *StartedRequest) (*EmptyResponse, error)
	// what's running??
	GetDeployments(context.Context, *InfoRequest) (*InfoResponse, error)
	// what kind of machine are we running on?
	// name/speed/ram/bla
	GetMachineInfo(context.Context, *MachineInfoRequest) (*MachineInfoResponse, error)
	// "undo" all actions (so they will be re-evaluated and applied on next scan)
	ClearActions(context.Context, *common.Void) (*common.Void, error)
	// shutdown autodeployer (this won't send a return message)
	StopAutodeployer(context.Context, *StopRequest) (*StopResponse, error)
	// download the "DownloadURL".
	Download(*StartedRequest, AutoDeployer_DownloadServer) error
	// start a download and put it into cache
	CacheURL(context.Context, *URLRequest) (*URLResponse, error)
	// install package (Asynchronous)
	InstallPackage(context.Context, *PackageInstallRequest) (*PackageInstallResponse, error)
	// check if package is installed
	CheckPackage(context.Context, *PackageInstallRequest) (*PackageInstallResponse, error)
}

func RegisterAutoDeployerServer(s *grpc.Server, srv AutoDeployerServer) {
	s.RegisterService(&_AutoDeployer_serviceDesc, srv)
}

func _AutoDeployer_Deploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeployRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).Deploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/Deploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).Deploy(ctx, req.(*DeployRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDeployer_Undeploy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UndeployRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).Undeploy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/Undeploy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).Undeploy(ctx, req.(*UndeployRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDeployer_InternalStartup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).InternalStartup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/InternalStartup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).InternalStartup(ctx, req.(*StartupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDeployer_AllocResources_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ResourceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).AllocResources(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/AllocResources",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).AllocResources(ctx, req.(*ResourceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDeployer_Terminated_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TerminationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).Terminated(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/Terminated",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).Terminated(ctx, req.(*TerminationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDeployer_Started_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StartedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).Started(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/Started",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).Started(ctx, req.(*StartedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDeployer_GetDeployments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).GetDeployments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/GetDeployments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).GetDeployments(ctx, req.(*InfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDeployer_GetMachineInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MachineInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).GetMachineInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/GetMachineInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).GetMachineInfo(ctx, req.(*MachineInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDeployer_ClearActions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).ClearActions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/ClearActions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).ClearActions(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDeployer_StopAutodeployer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(StopRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).StopAutodeployer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/StopAutodeployer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).StopAutodeployer(ctx, req.(*StopRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDeployer_Download_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(StartedRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(AutoDeployerServer).Download(m, &autoDeployerDownloadServer{stream})
}

type AutoDeployer_DownloadServer interface {
	Send(*BinaryDownload) error
	grpc.ServerStream
}

type autoDeployerDownloadServer struct {
	grpc.ServerStream
}

func (x *autoDeployerDownloadServer) Send(m *BinaryDownload) error {
	return x.ServerStream.SendMsg(m)
}

func _AutoDeployer_CacheURL_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(URLRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).CacheURL(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/CacheURL",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).CacheURL(ctx, req.(*URLRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDeployer_InstallPackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageInstallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).InstallPackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/InstallPackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).InstallPackage(ctx, req.(*PackageInstallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _AutoDeployer_CheckPackage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PackageInstallRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(AutoDeployerServer).CheckPackage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/autodeployer.AutoDeployer/CheckPackage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(AutoDeployerServer).CheckPackage(ctx, req.(*PackageInstallRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _AutoDeployer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "autodeployer.AutoDeployer",
	HandlerType: (*AutoDeployerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Deploy",
			Handler:    _AutoDeployer_Deploy_Handler,
		},
		{
			MethodName: "Undeploy",
			Handler:    _AutoDeployer_Undeploy_Handler,
		},
		{
			MethodName: "InternalStartup",
			Handler:    _AutoDeployer_InternalStartup_Handler,
		},
		{
			MethodName: "AllocResources",
			Handler:    _AutoDeployer_AllocResources_Handler,
		},
		{
			MethodName: "Terminated",
			Handler:    _AutoDeployer_Terminated_Handler,
		},
		{
			MethodName: "Started",
			Handler:    _AutoDeployer_Started_Handler,
		},
		{
			MethodName: "GetDeployments",
			Handler:    _AutoDeployer_GetDeployments_Handler,
		},
		{
			MethodName: "GetMachineInfo",
			Handler:    _AutoDeployer_GetMachineInfo_Handler,
		},
		{
			MethodName: "ClearActions",
			Handler:    _AutoDeployer_ClearActions_Handler,
		},
		{
			MethodName: "StopAutodeployer",
			Handler:    _AutoDeployer_StopAutodeployer_Handler,
		},
		{
			MethodName: "CacheURL",
			Handler:    _AutoDeployer_CacheURL_Handler,
		},
		{
			MethodName: "InstallPackage",
			Handler:    _AutoDeployer_InstallPackage_Handler,
		},
		{
			MethodName: "CheckPackage",
			Handler:    _AutoDeployer_CheckPackage_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Download",
			Handler:       _AutoDeployer_Download_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "protos/golang.conradwood.net/apis/autodeployer/autodeployer.proto",
}

func init() {
	proto.RegisterFile("protos/golang.conradwood.net/apis/autodeployer/autodeployer.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1856 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xec, 0x58, 0xdd, 0x8e, 0xdb, 0xc6,
	0x15, 0x2e, 0x57, 0xd2, 0xae, 0x74, 0xf4, 0x9b, 0xf1, 0xc6, 0xa5, 0x59, 0x67, 0xa1, 0xb2, 0x41,
	0xa3, 0xba, 0x8d, 0xec, 0x6e, 0x80, 0xd6, 0x08, 0xe0, 0x06, 0x5a, 0x51, 0x76, 0x98, 0xee, 0x8f,
	0x3a, 0xda, 0x8d, 0xfb, 0x73, 0x45, 0x93, 0x63, 0x2d, 0xb1, 0x14, 0xc9, 0x72, 0xa8, 0xb8, 0x7a,
	0x88, 0xa2, 0x7d, 0x80, 0xde, 0xf7, 0xa6, 0xef, 0xd4, 0x47, 0xe8, 0x5d, 0xaf, 0x8b, 0xf9, 0xa1,
	0xc8, 0xa1, 0x68, 0x39, 0x41, 0x0a, 0x14, 0x28, 0x72, 0x25, 0x9e, 0x6f, 0xce, 0x9c, 0x99, 0x39,
	0x73, 0xce, 0x77, 0xce, 0x08, 0x26, 0x71, 0x12, 0xa5, 0x11, 0x7d, 0xbc, 0x8c, 0x02, 0x27, 0x5c,
	0x8e, 0xdd, 0x28, 0x4c, 0x1c, 0xef, 0x4d, 0x14, 0x79, 0xe3, 0x90, 0xa4, 0x8f, 0x9d, 0xd8, 0xa7,
	0x8f, 0x9d, 0x75, 0x1a, 0x79, 0x24, 0x0e, 0xa2, 0x0d, 0x49, 0x14, 0x61, 0xcc, 0xe7, 0xa2, 0x4e,
	0x11, 0x33, 0xc6, 0x7b, 0x2c, 0xb9, 0xd1, 0x6a, 0x15, 0x85, 0xf2, 0x47, 0xcc, 0x36, 0x3e, 0xdd,
	0xa3, 0x2f, 0x8c, 0xae, 0xa2, 0xf0, 0x8e, 0x6c, 0x14, 0x41, 0xcc, 0x35, 0xff, 0xde, 0x80, 0xae,
	0xc5, 0x61, 0x4c, 0xfe, 0xb8, 0x26, 0x34, 0x45, 0x43, 0x68, 0x5b, 0xd1, 0x9b, 0x30, 0x88, 0x1c,
	0xef, 0x06, 0x9f, 0xeb, 0xda, 0x50, 0x1b, 0xb5, 0x70, 0x11, 0x42, 0x26, 0x74, 0xb6, 0x22, 0x25,
	0x89, 0x7e, 0xc0, 0x55, 0x14, 0x0c, 0x3d, 0x82, 0x41, 0x26, 0xcf, 0x1d, 0x4a, 0xdf, 0x44, 0x89,
	0xa7, 0xd7, 0xb8, 0xde, 0x0e, 0x8e, 0xee, 0xc3, 0xe1, 0x99, 0x1f, 0x3a, 0xc9, 0x46, 0xaf, 0x73,
	0x0d, 0x29, 0x21, 0x04, 0xf5, 0x49, 0xb2, 0xa4, 0x7a, 0x63, 0x58, 0x1b, 0xb5, 0x30, 0xff, 0x46,
	0x3a, 0x1c, 0x9d, 0xad, 0xfd, 0xc0, 0xb3, 0x2d, 0xfd, 0x68, 0xa8, 0x8d, 0xea, 0x38, 0x13, 0xf9,
	0xae, 0xc4, 0xf9, 0x48, 0x98, 0xda, 0x96, 0xde, 0x94, 0xbb, 0x2a, 0x60, 0xe8, 0x21, 0xb4, 0x2e,
	0x9d, 0x15, 0xa1, 0xb1, 0xe3, 0x12, 0xbd, 0xc5, 0x15, 0x72, 0x80, 0x8d, 0xbe, 0x48, 0xa2, 0x75,
	0x1c, 0x3a, 0x2b, 0xa2, 0x83, 0x18, 0xdd, 0x02, 0xe8, 0x0b, 0x18, 0x4c, 0xd6, 0x69, 0x84, 0xc9,
	0xd2, 0xa7, 0x69, 0xe2, 0xa4, 0x7e, 0x14, 0xea, 0xed, 0x61, 0x6d, 0xd4, 0x3e, 0x3d, 0x19, 0x2b,
	0x8e, 0x2d, 0x6b, 0xe1, 0x9d, 0x79, 0xe8, 0x04, 0x40, 0xec, 0xeb, 0x7a, 0x13, 0x13, 0xbd, 0xc3,
	0x97, 0x2a, 0x20, 0x68, 0x04, 0xfd, 0x45, 0xea, 0xa4, 0xbe, 0x7b, 0xed, 0x24, 0x4b, 0x92, 0x5a,
	0x7e, 0xa2, 0x77, 0xb9, 0x52, 0x19, 0x66, 0xbe, 0x9b, 0xaf, 0x5f, 0x05, 0xbe, 0xab, 0xf7, 0x86,
	0xda, 0xa8, 0x89, 0xa5, 0x84, 0x7e, 0x06, 0x87, 0xe7, 0xfe, 0xca, 0x4f, 0xa9, 0xde, 0x1f, 0x6a,
	0xa3, 0xf6, 0xe9, 0xb1, 0xba, 0x47, 0x31, 0x86, 0xa5, 0x0e, 0xfa, 0x15, 0x74, 0x26, 0x71, 0x8c,
	0xc9, 0x6b, 0x92, 0x90, 0xd0, 0x25, 0xfa, 0x80, 0xcf, 0x31, 0x4a, 0xe7, 0x2a, 0x68, 0x60, 0x45,
	0x9f, 0xf9, 0x1e, 0x93, 0x38, 0xa2, 0x7e, 0x1a, 0x25, 0x1b, 0xdb, 0xd2, 0xdf, 0xe3, 0x57, 0xa3,
	0x60, 0xc8, 0x80, 0xa6, 0x25, 0x23, 0x5c, 0x47, 0xfc, 0x30, 0x5b, 0x39, 0xbf, 0x3b, 0x92, 0xd8,
	0xe1, 0xeb, 0x48, 0xbf, 0x37, 0xd4, 0x46, 0x1d, 0xac, 0x60, 0xe6, 0xbf, 0x0f, 0x33, 0xa7, 0x31,
	0xf1, 0xbb, 0x30, 0xfd, 0xbf, 0x08, 0xd3, 0x63, 0x68, 0xcc, 0xa3, 0x84, 0x47, 0x69, 0x6d, 0xd4,
	0xc5, 0x42, 0x40, 0x3f, 0x86, 0x5e, 0xee, 0x8f, 0xd8, 0x49, 0x6f, 0x79, 0x40, 0xb6, 0x70, 0x09,
	0x45, 0xbf, 0x80, 0x43, 0xb6, 0xd0, 0x9a, 0xf2, 0x80, 0xeb, 0x9d, 0x9e, 0x8c, 0x15, 0x6e, 0xcd,
	0xb5, 0x85, 0x16, 0x96, 0xda, 0xcc, 0x3e, 0x5e, 0x87, 0xa9, 0xbf, 0x22, 0x0b, 0xe2, 0x46, 0xa1,
	0x47, 0x79, 0x40, 0xd6, 0x71, 0x09, 0xdd, 0x49, 0x8b, 0x7b, 0xdf, 0x32, 0x2d, 0x8e, 0x2b, 0xd2,
	0x82, 0xeb, 0xd0, 0x28, 0xf8, 0x8a, 0x78, 0x3c, 0x8a, 0xde, 0xe7, 0x51, 0xa4, 0x60, 0x68, 0x00,
	0xb5, 0xb9, 0xef, 0xe9, 0xf7, 0xf9, 0x74, 0xf6, 0xc9, 0x62, 0x60, 0x7a, 0xeb, 0x07, 0xde, 0xdc,
	0xf7, 0xa8, 0xfe, 0xfd, 0x61, 0x6d, 0x54, 0xc7, 0x39, 0xc0, 0xbc, 0xcd, 0xa2, 0xdb, 0xb6, 0x74,
	0x5d, 0x44, 0xaa, 0x90, 0x58, 0x0a, 0xb2, 0x2f, 0x16, 0x4a, 0xfa, 0x03, 0x91, 0x82, 0x99, 0xcc,
	0x22, 0x96, 0x07, 0x91, 0x6d, 0xe9, 0x06, 0x1f, 0xca, 0x44, 0xf3, 0x6f, 0x5a, 0x76, 0x1d, 0x98,
	0xd0, 0x38, 0x0a, 0x29, 0x57, 0x5e, 0xac, 0x5d, 0x97, 0x50, 0xca, 0x13, 0xaf, 0x89, 0x33, 0x91,
	0x8d, 0xe0, 0x75, 0x18, 0xfa, 0xe1, 0x92, 0xe7, 0x5b, 0x13, 0x67, 0x22, 0x1b, 0xb9, 0x20, 0x94,
	0x3a, 0x4b, 0x22, 0x33, 0x2c, 0x13, 0xf3, 0x20, 0xa8, 0x17, 0x83, 0x20, 0x3f, 0x44, 0x43, 0x39,
	0x44, 0x0f, 0x0e, 0x6c, 0x4b, 0x3f, 0xe4, 0xd8, 0x81, 0x6d, 0x99, 0x7d, 0xe8, 0xce, 0x56, 0x71,
	0xba, 0xdd, 0x9c, 0x79, 0x06, 0xe8, 0x9a, 0x24, 0x2b, 0x3f, 0x14, 0x61, 0x2d, 0xcb, 0xda, 0x31,
	0x34, 0x2e, 0xe8, 0xd2, 0xf7, 0x24, 0x53, 0x08, 0x81, 0x2d, 0xf2, 0xdc, 0xf1, 0x03, 0xe2, 0xc9,
	0xdd, 0x4a, 0xc9, 0x7c, 0x05, 0xbd, 0x45, 0xea, 0x24, 0x29, 0xf1, 0xf6, 0xcf, 0x67, 0x91, 0x2a,
	0x79, 0x42, 0xb1, 0x53, 0x42, 0xb7, 0x1c, 0x51, 0xcb, 0x39, 0xc2, 0x7c, 0x2a, 0xd7, 0x58, 0xc7,
	0xfb, 0xd7, 0x60, 0xb7, 0x6f, 0x5b, 0xdc, 0x30, 0xbb, 0x7d, 0xdb, 0x32, 0xff, 0x59, 0xe3, 0x89,
	0x27, 0xa6, 0xca, 0x2b, 0x19, 0x40, 0x2d, 0xe7, 0xc1, 0xda, 0xff, 0x9a, 0xff, 0x4e, 0x00, 0x5e,
	0x46, 0xc9, 0x9d, 0x1f, 0x2e, 0x19, 0x29, 0x88, 0xcb, 0x2a, 0x20, 0x85, 0xf2, 0x74, 0xf4, 0x35,
	0xca, 0xd3, 0x05, 0xc0, 0x82, 0xb8, 0xeb, 0x84, 0xf0, 0x75, 0x9a, 0x9c, 0xcd, 0x3e, 0x56, 0x73,
	0xbd, 0xe4, 0x8e, 0x71, 0xae, 0x3f, 0x0b, 0xd3, 0x64, 0x83, 0x0b, 0x06, 0x76, 0xd2, 0xba, 0xf5,
	0xcd, 0xd3, 0xfa, 0x86, 0x92, 0x05, 0x49, 0x31, 0xdf, 0x1f, 0xe7, 0xe0, 0x26, 0x56, 0x30, 0xe3,
	0x19, 0xf4, 0x4b, 0x5b, 0x60, 0x37, 0x74, 0x47, 0x36, 0xd9, 0x0d, 0xdd, 0x91, 0x0d, 0xbb, 0xef,
	0xaf, 0x9c, 0x60, 0x4d, 0xe4, 0xd5, 0x08, 0xe1, 0xd3, 0x83, 0xa7, 0x9a, 0xf9, 0x0c, 0xfa, 0x8c,
	0x01, 0xd6, 0x89, 0x4b, 0xf6, 0x07, 0xc7, 0x36, 0x77, 0x98, 0x89, 0x86, 0xcc, 0x1d, 0x73, 0x04,
	0x83, 0x7c, 0xba, 0x0c, 0x90, 0xad, 0xa6, 0x36, 0xac, 0xe5, 0x9a, 0x3f, 0x81, 0x36, 0x2b, 0xa7,
	0xd9, 0x22, 0xc5, 0x22, 0xad, 0xa9, 0x45, 0xda, 0xfc, 0xeb, 0x01, 0xb4, 0xa5, 0xe0, 0x4d, 0xe2,
	0x58, 0x26, 0xa2, 0x96, 0x25, 0x22, 0x7a, 0x9a, 0x55, 0x0b, 0xc6, 0xb8, 0x7c, 0x3f, 0xed, 0x53,
	0xbd, 0x8a, 0x91, 0xf9, 0x82, 0x05, 0x5d, 0x34, 0x29, 0xf5, 0xa0, 0x3c, 0x04, 0xdb, 0xa7, 0x3f,
	0xa8, 0x9a, 0x2c, 0x55, 0x70, 0xa9, 0x6b, 0xad, 0xe6, 0x90, 0xbc, 0x40, 0x34, 0xbe, 0x65, 0x81,
	0x38, 0xac, 0x2a, 0x10, 0xe6, 0x33, 0xe8, 0x08, 0xef, 0x49, 0x1f, 0x7f, 0x0c, 0xf5, 0x49, 0x1c,
	0x0b, 0x17, 0xb7, 0x4f, 0x1f, 0x54, 0xad, 0xc6, 0x7d, 0x87, 0xb9, 0x9a, 0xf9, 0x4b, 0xe8, 0xdf,
	0x84, 0x9e, 0x72, 0x8e, 0xb2, 0x53, 0x8f, 0xa1, 0x71, 0x16, 0x44, 0xee, 0x9d, 0xe4, 0x15, 0x21,
	0x98, 0x08, 0x06, 0xf9, 0x44, 0x49, 0x7b, 0xc7, 0x80, 0x2e, 0x1c, 0xf7, 0xd6, 0x0f, 0x49, 0xe1,
	0x42, 0xcd, 0x7f, 0xd5, 0xe1, 0x9e, 0x02, 0xcb, 0x9d, 0x9a, 0xd0, 0x91, 0x30, 0xa7, 0x79, 0xbe,
	0xe3, 0x16, 0x56, 0x30, 0xf4, 0x04, 0xee, 0xb1, 0x96, 0x20, 0x0b, 0x80, 0x2f, 0x49, 0x42, 0x59,
	0x37, 0x21, 0x88, 0xa8, 0x6a, 0x88, 0x85, 0xcf, 0x22, 0x8d, 0xe2, 0x98, 0xd1, 0x7f, 0x8d, 0x6f,
	0x78, 0x2b, 0xa3, 0x31, 0xa0, 0x49, 0xc1, 0x1d, 0x0a, 0x95, 0x54, 0x8c, 0xb0, 0x3b, 0x90, 0x6e,
	0xce, 0x0a, 0x0a, 0xbb, 0xc3, 0x2e, 0x2e, 0xa1, 0x8c, 0x6a, 0xec, 0x90, 0xa6, 0x4e, 0xe8, 0x92,
	0x6d, 0x5d, 0x28, 0x20, 0x6c, 0x9c, 0x07, 0x83, 0x1d, 0xde, 0x50, 0xa2, 0x1f, 0xf1, 0xf0, 0x28,
	0x20, 0xcc, 0x13, 0x53, 0x7e, 0x5e, 0xa9, 0xd1, 0x14, 0x9e, 0x28, 0x62, 0xe8, 0x25, 0x74, 0xd8,
	0x8c, 0x0b, 0x87, 0x1f, 0x85, 0xea, 0x2d, 0x7e, 0xbf, 0x9f, 0xa8, 0xf7, 0x5b, 0xe1, 0xe6, 0x71,
	0x71, 0x96, 0x20, 0x22, 0xc5, 0x10, 0xfa, 0x0d, 0x00, 0xe3, 0x61, 0xb9, 0x34, 0x70, 0xb3, 0x3f,
	0x7f, 0xb7, 0xd9, 0x7c, 0x8e, 0x64, 0xb7, 0x1c, 0x30, 0x3e, 0x83, 0xf7, 0x76, 0x56, 0x2d, 0x72,
	0x4f, 0xb7, 0x82, 0x7b, 0xba, 0x05, 0xee, 0x61, 0xd4, 0x55, 0xb2, 0xff, 0x2e, 0xea, 0x2a, 0x4e,
	0x37, 0x2d, 0x80, 0x1b, 0x7c, 0x9e, 0xc5, 0xf3, 0x6e, 0x59, 0xfa, 0x10, 0xba, 0xcf, 0xa3, 0xc4,
	0x25, 0x59, 0x7d, 0x91, 0x91, 0xad, 0x82, 0xe6, 0x5f, 0x34, 0x68, 0x73, 0x33, 0x6f, 0x2d, 0x6f,
	0x23, 0xe8, 0x9f, 0x6d, 0x52, 0x42, 0xb3, 0x29, 0xb2, 0xf6, 0xd6, 0x71, 0x19, 0x66, 0x11, 0x70,
	0x1d, 0xa5, 0x4e, 0xc0, 0x71, 0x1e, 0x97, 0x75, 0x5c, 0x40, 0xd8, 0x8e, 0xa6, 0x8e, 0x7b, 0x4b,
	0x2c, 0x9f, 0x3a, 0xaf, 0x58, 0x0d, 0xaf, 0x8b, 0x1d, 0x29, 0xa0, 0xf9, 0x53, 0x78, 0x7f, 0xee,
	0xb8, 0x77, 0xce, 0x92, 0xf0, 0xe0, 0x0a, 0x82, 0xec, 0x88, 0x08, 0xea, 0xbc, 0xa3, 0x12, 0x7b,
	0xe3, 0xdf, 0xe6, 0x17, 0x70, 0xbf, 0xac, 0x2c, 0x0f, 0x52, 0xa1, 0xcd, 0xba, 0x39, 0xa9, 0xb6,
	0x6d, 0x20, 0x72, 0xc0, 0x74, 0xa1, 0xcd, 0x92, 0x28, 0x5b, 0xce, 0x84, 0x8e, 0xfd, 0xfa, 0x32,
	0x4a, 0xb3, 0x74, 0xd4, 0x44, 0x53, 0x59, 0xc4, 0x58, 0xe6, 0x62, 0x22, 0x22, 0xe8, 0x2a, 0xbc,
	0x24, 0x7f, 0x4a, 0x79, 0x79, 0x94, 0xa6, 0xab, 0x86, 0x4c, 0x0b, 0x3a, 0x62, 0x91, 0xbc, 0xc3,
	0x53, 0x17, 0x38, 0xaa, 0xca, 0xf1, 0x03, 0x35, 0xc7, 0xcd, 0x88, 0x35, 0xb3, 0x5e, 0xfe, 0x48,
	0xdb, 0x21, 0x76, 0xed, 0x1b, 0x13, 0xfb, 0x43, 0x68, 0x65, 0xa5, 0x4c, 0x14, 0xb9, 0x0e, 0xce,
	0x01, 0xd3, 0x62, 0x85, 0x2e, 0x5f, 0xf0, 0xdc, 0xa7, 0x29, 0x7a, 0x02, 0x0d, 0xf6, 0x9d, 0xb1,
	0xb0, 0xa1, 0x2e, 0x56, 0x54, 0xc7, 0x42, 0xd1, 0x3c, 0x87, 0x9e, 0x20, 0x9d, 0x2c, 0x68, 0x18,
	0xf9, 0x88, 0xc7, 0xcb, 0x73, 0x3f, 0x20, 0x61, 0x7e, 0x5f, 0x25, 0x94, 0xdd, 0xa6, 0xe5, 0xa4,
	0x8e, 0xdc, 0x18, 0xff, 0x7e, 0xf4, 0x67, 0x0d, 0x06, 0xe5, 0xca, 0x82, 0xba, 0xd0, 0x9a, 0xe3,
	0xd9, 0x7c, 0x82, 0xed, 0xcb, 0x17, 0x83, 0xef, 0xa1, 0x0e, 0x34, 0x17, 0xd7, 0x13, 0x7c, 0xcd,
	0x24, 0x0d, 0xf5, 0xa1, 0x6d, 0x5d, 0xbd, 0xbc, 0x3c, 0xbf, 0x9a, 0x58, 0x0c, 0x38, 0x40, 0x3d,
	0x00, 0x3c, 0x5b, 0x5c, 0xdd, 0xe0, 0x29, 0x93, 0x6b, 0x4c, 0x7d, 0xf6, 0xdb, 0xd9, 0xf4, 0x66,
	0x31, 0xc3, 0x83, 0x3a, 0x1b, 0xbd, 0x9e, 0xe1, 0x0b, 0xfb, 0x72, 0x72, 0x3d, 0xb3, 0x06, 0x0d,
	0x36, 0x7d, 0x3a, 0x99, 0x7e, 0x3e, 0xb3, 0xb8, 0xc9, 0xc1, 0xa1, 0xb0, 0x7e, 0x35, 0x9f, 0xb3,
	0xc9, 0x47, 0xa7, 0xff, 0x68, 0x42, 0xa7, 0x48, 0xd6, 0x68, 0x0a, 0x87, 0xe2, 0x1b, 0xed, 0xbb,
	0x08, 0xe3, 0x61, 0xf5, 0xa0, 0x0c, 0x10, 0x1b, 0x9a, 0x59, 0x09, 0x42, 0x1f, 0xa8, 0x9a, 0xa5,
	0x9a, 0x66, 0x9c, 0xbc, 0x6d, 0x58, 0x9a, 0xba, 0x84, 0xbe, 0x1d, 0xa6, 0x24, 0x09, 0x9d, 0x40,
	0xb6, 0x71, 0xe8, 0xe1, 0x5b, 0xba, 0x3b, 0x61, 0xf0, 0x83, 0xbd, 0xbd, 0x1f, 0xba, 0x82, 0xde,
	0x24, 0x08, 0x22, 0x77, 0x1b, 0x26, 0xe5, 0x0d, 0x96, 0x5a, 0xab, 0xf2, 0x06, 0x77, 0x5a, 0xa7,
	0x5f, 0x03, 0x64, 0x2f, 0x0a, 0xe2, 0xa1, 0xa1, 0xaa, 0xbd, 0xfb, 0xd6, 0x30, 0x4a, 0x6e, 0x55,
	0x9e, 0x27, 0xc8, 0x82, 0x23, 0xf9, 0xb4, 0xa8, 0x3c, 0xe5, 0xf6, 0xc5, 0xb1, 0xdf, 0xca, 0x0b,
	0xe8, 0xbd, 0x20, 0x69, 0x1e, 0x66, 0x14, 0x95, 0xba, 0x8d, 0x42, 0x13, 0x60, 0x18, 0x55, 0x43,
	0xd2, 0xd0, 0x0d, 0x37, 0x54, 0x28, 0x32, 0xe5, 0xf3, 0xed, 0x36, 0x15, 0xc6, 0x0f, 0xdf, 0x59,
	0xa1, 0xd0, 0x23, 0xe8, 0x4c, 0x03, 0xe2, 0x24, 0x13, 0x97, 0x39, 0x86, 0xa2, 0xce, 0x58, 0xfe,
	0x65, 0xf9, 0x65, 0xe4, 0x7b, 0x86, 0x22, 0x21, 0x1b, 0x06, 0x8c, 0x41, 0x8a, 0x3d, 0x40, 0xf9,
	0x34, 0x05, 0x02, 0x2c, 0x9f, 0x46, 0xa1, 0xad, 0xcf, 0xa1, 0xb9, 0xcd, 0xe1, 0xfd, 0xde, 0x2d,
	0x8d, 0xaa, 0xf9, 0xff, 0x44, 0x43, 0x9f, 0x41, 0x93, 0xf3, 0x3f, 0x2b, 0x35, 0xa5, 0x2e, 0x36,
	0x2f, 0x6f, 0xc6, 0x83, 0x8a, 0x11, 0xb9, 0x95, 0x3f, 0x40, 0x4f, 0x72, 0xb8, 0xac, 0x04, 0xe8,
	0x47, 0xaa, 0x72, 0x65, 0x35, 0x31, 0x3e, 0xdc, 0xaf, 0x24, 0x8d, 0xff, 0x0e, 0x3a, 0xd3, 0x5b,
	0xe2, 0xde, 0xfd, 0xf7, 0x4d, 0x9f, 0x61, 0xf8, 0x28, 0x24, 0x69, 0xf1, 0xcf, 0x64, 0xf9, 0xf7,
	0xb2, 0x13, 0xfb, 0x54, 0xb1, 0xf0, 0xfb, 0x8f, 0xbe, 0xe6, 0x5f, 0xde, 0xaf, 0x0e, 0xf9, 0x9f,
	0xcd, 0x9f, 0xfc, 0x27, 0x00, 0x00, 0xff, 0xff, 0xb2, 0xd2, 0xb0, 0xb9, 0x2b, 0x17, 0x00, 0x00,
}
