// Code generated by protoc-gen-go.
// source: golang.singingcat.net/apis/scupdate/scupdate.proto
// DO NOT EDIT!

/*
Package scupdate is a generated protocol buffer package.

It is generated from these files:
	golang.singingcat.net/apis/scupdate/scupdate.proto

It has these top-level messages:
	V2UpdateRequest
	V2Status
	V2FileReference
	ActiveUpdate
	Tracker
	UpdateInfo
	UpdateRequest
	BlobUpdateRequest
	Match
	UpdateResponse
	ComReceived
	UpdateStatus
	UpdateStatusList
	FirmwareInfo
	HistoryList
	History
	UpgradeRepoRequest
	UpdateFromRepoRequest
	UpdateLog
*/
package scupdate

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"
import gitserver "golang.conradwood.net/apis/gitserver"
import singingcat "golang.singingcat.net/apis/singingcat"
import scapply "golang.singingcat.net/apis/scapply"
import scweb "golang.singingcat.net/apis/scweb"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type UpgradeResult int32

const (
	UpgradeResult_PENDING  UpgradeResult = 0
	UpgradeResult_TIMEOUT  UpgradeResult = 1
	UpgradeResult_SUCCESS  UpgradeResult = 2
	UpgradeResult_REJECTED UpgradeResult = 3
	UpgradeResult_FAILED   UpgradeResult = 4
)

var UpgradeResult_name = map[int32]string{
	0: "PENDING",
	1: "TIMEOUT",
	2: "SUCCESS",
	3: "REJECTED",
	4: "FAILED",
}
var UpgradeResult_value = map[string]int32{
	"PENDING":  0,
	"TIMEOUT":  1,
	"SUCCESS":  2,
	"REJECTED": 3,
	"FAILED":   4,
}

func (x UpgradeResult) String() string {
	return proto.EnumName(UpgradeResult_name, int32(x))
}
func (UpgradeResult) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// flags the module understands when triggering an update
type UpdateFlags int32

const (
	// \brief unless this is set, flags are ignored
	UpdateFlags_FLASH_FLAGS_USE UpdateFlags = 0
	// \brief if set, will mark this as an app and set it to 'latest' in partition table
	UpdateFlags_FLASH_FLAGS_SET_LATEST_APP UpdateFlags = 1
	// \brief if set, user app will be stopped before flashing
	UpdateFlags_FLASH_FLAGS_STOP_USERAPP UpdateFlags = 2
	// \brief if set, user app will start after flashing
	UpdateFlags_FLASH_FLAGS_START_USERAPP UpdateFlags = 3
	// \brief if set, will mark this as a user app and update config to execute this
	UpdateFlags_FLASH_FLAGS_SET_LATEST_USERAPP UpdateFlags = 4
	// \brief if set, will erase section of flash in one go prior to receiving data. otherwise, will flash each sector as it is received
	UpdateFlags_FLASH_FLAGS_PRE_ERASE UpdateFlags = 5
	// \brief if set, return baseaddress of available slot for userapp instead of firmware
	UpdateFlags_FLASH_FLAGS_RETURN_APP_SLOT UpdateFlags = 6
)

var UpdateFlags_name = map[int32]string{
	0: "FLASH_FLAGS_USE",
	1: "FLASH_FLAGS_SET_LATEST_APP",
	2: "FLASH_FLAGS_STOP_USERAPP",
	3: "FLASH_FLAGS_START_USERAPP",
	4: "FLASH_FLAGS_SET_LATEST_USERAPP",
	5: "FLASH_FLAGS_PRE_ERASE",
	6: "FLASH_FLAGS_RETURN_APP_SLOT",
}
var UpdateFlags_value = map[string]int32{
	"FLASH_FLAGS_USE":                0,
	"FLASH_FLAGS_SET_LATEST_APP":     1,
	"FLASH_FLAGS_STOP_USERAPP":       2,
	"FLASH_FLAGS_START_USERAPP":      3,
	"FLASH_FLAGS_SET_LATEST_USERAPP": 4,
	"FLASH_FLAGS_PRE_ERASE":          5,
	"FLASH_FLAGS_RETURN_APP_SLOT":    6,
}

func (x UpdateFlags) String() string {
	return proto.EnumName(UpdateFlags_name, int32(x))
}
func (UpdateFlags) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type V2StatusIndicator int32

const (
	V2StatusIndicator_UNDEFINED         V2StatusIndicator = 0
	V2StatusIndicator_INITIAL_STATE     V2StatusIndicator = 1
	V2StatusIndicator_GOT_CUR_BASE      V2StatusIndicator = 2
	V2StatusIndicator_GOT_MATCHING_FILE V2StatusIndicator = 3
	V2StatusIndicator_STREAM_SETUP_OK   V2StatusIndicator = 4
	V2StatusIndicator_DATA_COMPLETE     V2StatusIndicator = 5
	V2StatusIndicator_RESETTING         V2StatusIndicator = 6
	V2StatusIndicator_COMPLETED         V2StatusIndicator = 7
	V2StatusIndicator_UPDATE_FAILED     V2StatusIndicator = 8
)

var V2StatusIndicator_name = map[int32]string{
	0: "UNDEFINED",
	1: "INITIAL_STATE",
	2: "GOT_CUR_BASE",
	3: "GOT_MATCHING_FILE",
	4: "STREAM_SETUP_OK",
	5: "DATA_COMPLETE",
	6: "RESETTING",
	7: "COMPLETED",
	8: "UPDATE_FAILED",
}
var V2StatusIndicator_value = map[string]int32{
	"UNDEFINED":         0,
	"INITIAL_STATE":     1,
	"GOT_CUR_BASE":      2,
	"GOT_MATCHING_FILE": 3,
	"STREAM_SETUP_OK":   4,
	"DATA_COMPLETE":     5,
	"RESETTING":         6,
	"COMPLETED":         7,
	"UPDATE_FAILED":     8,
}

func (x V2StatusIndicator) String() string {
	return proto.EnumName(V2StatusIndicator_name, int32(x))
}
func (V2StatusIndicator) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type V2UpdateRequest struct {
	ID          uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ModuleID    uint64 `protobuf:"varint,2,opt,name=ModuleID" json:"ModuleID,omitempty"`
	Created     uint32 `protobuf:"varint,3,opt,name=Created" json:"Created,omitempty"`
	BuildNumber uint64 `protobuf:"varint,4,opt,name=BuildNumber" json:"BuildNumber,omitempty"`
	Repository  uint64 `protobuf:"varint,5,opt,name=Repository" json:"Repository,omitempty"`
	RequestedBy string `protobuf:"bytes,6,opt,name=RequestedBy" json:"RequestedBy,omitempty"`
	Context     []byte `protobuf:"bytes,7,opt,name=Context,proto3" json:"Context,omitempty"`
}

func (m *V2UpdateRequest) Reset()                    { *m = V2UpdateRequest{} }
func (m *V2UpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*V2UpdateRequest) ProtoMessage()               {}
func (*V2UpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *V2UpdateRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *V2UpdateRequest) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *V2UpdateRequest) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *V2UpdateRequest) GetBuildNumber() uint64 {
	if m != nil {
		return m.BuildNumber
	}
	return 0
}

func (m *V2UpdateRequest) GetRepository() uint64 {
	if m != nil {
		return m.Repository
	}
	return 0
}

func (m *V2UpdateRequest) GetRequestedBy() string {
	if m != nil {
		return m.RequestedBy
	}
	return ""
}

func (m *V2UpdateRequest) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

// status progress for an update request. if it does not exist it will be created. also, removing it, causes the whole flash thing to restart
type V2Status struct {
	ID                  uint64            `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UpdateRequest       *V2UpdateRequest  `protobuf:"bytes,2,opt,name=UpdateRequest" json:"UpdateRequest,omitempty"`
	CurrentStatus       V2StatusIndicator `protobuf:"varint,3,opt,name=CurrentStatus,enum=scupdate.V2StatusIndicator" json:"CurrentStatus,omitempty"`
	LastComSent         uint32            `protobuf:"varint,4,opt,name=LastComSent" json:"LastComSent,omitempty"`
	CurFirmwareBase     uint32            `protobuf:"varint,5,opt,name=CurFirmwareBase" json:"CurFirmwareBase,omitempty"`
	CurFirmwareVersion  uint32            `protobuf:"varint,6,opt,name=CurFirmwareVersion" json:"CurFirmwareVersion,omitempty"`
	CurAppBase          uint32            `protobuf:"varint,7,opt,name=CurAppBase" json:"CurAppBase,omitempty"`
	CurAppVersion       uint32            `protobuf:"varint,8,opt,name=CurAppVersion" json:"CurAppVersion,omitempty"`
	FileReferenceID     uint64            `protobuf:"varint,9,opt,name=FileReferenceID" json:"FileReferenceID,omitempty"`
	FileDescriptor      uint64            `protobuf:"varint,10,opt,name=FileDescriptor" json:"FileDescriptor,omitempty"`
	LastAcked           uint64            `protobuf:"varint,11,opt,name=LastAcked" json:"LastAcked,omitempty"`
	LastSent            uint64            `protobuf:"varint,12,opt,name=LastSent" json:"LastSent,omitempty"`
	LastAckReceived     uint32            `protobuf:"varint,13,opt,name=LastAckReceived" json:"LastAckReceived,omitempty"`
	LastDataSent        uint32            `protobuf:"varint,14,opt,name=LastDataSent" json:"LastDataSent,omitempty"`
	FatalFailure        bool              `protobuf:"varint,15,opt,name=FatalFailure" json:"FatalFailure,omitempty"`
	FailedTimestamp     uint32            `protobuf:"varint,16,opt,name=FailedTimestamp" json:"FailedTimestamp,omitempty"`
	ErrorMessage        string            `protobuf:"bytes,17,opt,name=ErrorMessage" json:"ErrorMessage,omitempty"`
	BytesSentAndAcked   uint64            `protobuf:"varint,18,opt,name=BytesSentAndAcked" json:"BytesSentAndAcked,omitempty"`
	CloseTN             uint64            `protobuf:"varint,19,opt,name=CloseTN" json:"CloseTN,omitempty"`
	LastResetSent       uint32            `protobuf:"varint,20,opt,name=LastResetSent" json:"LastResetSent,omitempty"`
	CompletionTimestamp uint32            `protobuf:"varint,21,opt,name=CompletionTimestamp" json:"CompletionTimestamp,omitempty"`
}

func (m *V2Status) Reset()                    { *m = V2Status{} }
func (m *V2Status) String() string            { return proto.CompactTextString(m) }
func (*V2Status) ProtoMessage()               {}
func (*V2Status) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *V2Status) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *V2Status) GetUpdateRequest() *V2UpdateRequest {
	if m != nil {
		return m.UpdateRequest
	}
	return nil
}

func (m *V2Status) GetCurrentStatus() V2StatusIndicator {
	if m != nil {
		return m.CurrentStatus
	}
	return V2StatusIndicator_UNDEFINED
}

func (m *V2Status) GetLastComSent() uint32 {
	if m != nil {
		return m.LastComSent
	}
	return 0
}

func (m *V2Status) GetCurFirmwareBase() uint32 {
	if m != nil {
		return m.CurFirmwareBase
	}
	return 0
}

func (m *V2Status) GetCurFirmwareVersion() uint32 {
	if m != nil {
		return m.CurFirmwareVersion
	}
	return 0
}

func (m *V2Status) GetCurAppBase() uint32 {
	if m != nil {
		return m.CurAppBase
	}
	return 0
}

func (m *V2Status) GetCurAppVersion() uint32 {
	if m != nil {
		return m.CurAppVersion
	}
	return 0
}

func (m *V2Status) GetFileReferenceID() uint64 {
	if m != nil {
		return m.FileReferenceID
	}
	return 0
}

func (m *V2Status) GetFileDescriptor() uint64 {
	if m != nil {
		return m.FileDescriptor
	}
	return 0
}

func (m *V2Status) GetLastAcked() uint64 {
	if m != nil {
		return m.LastAcked
	}
	return 0
}

func (m *V2Status) GetLastSent() uint64 {
	if m != nil {
		return m.LastSent
	}
	return 0
}

func (m *V2Status) GetLastAckReceived() uint32 {
	if m != nil {
		return m.LastAckReceived
	}
	return 0
}

func (m *V2Status) GetLastDataSent() uint32 {
	if m != nil {
		return m.LastDataSent
	}
	return 0
}

func (m *V2Status) GetFatalFailure() bool {
	if m != nil {
		return m.FatalFailure
	}
	return false
}

func (m *V2Status) GetFailedTimestamp() uint32 {
	if m != nil {
		return m.FailedTimestamp
	}
	return 0
}

func (m *V2Status) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *V2Status) GetBytesSentAndAcked() uint64 {
	if m != nil {
		return m.BytesSentAndAcked
	}
	return 0
}

func (m *V2Status) GetCloseTN() uint64 {
	if m != nil {
		return m.CloseTN
	}
	return 0
}

func (m *V2Status) GetLastResetSent() uint32 {
	if m != nil {
		return m.LastResetSent
	}
	return 0
}

func (m *V2Status) GetCompletionTimestamp() uint32 {
	if m != nil {
		return m.CompletionTimestamp
	}
	return 0
}

// a reference to a file in the artefact server. store in database for easier access
type V2FileReference struct {
	ID          uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Filename    string `protobuf:"bytes,2,opt,name=Filename" json:"Filename,omitempty"`
	ArtefactID  uint64 `protobuf:"varint,3,opt,name=ArtefactID" json:"ArtefactID,omitempty"`
	BuildNumber uint64 `protobuf:"varint,4,opt,name=BuildNumber" json:"BuildNumber,omitempty"`
	Base        uint32 `protobuf:"varint,5,opt,name=Base" json:"Base,omitempty"`
	RepoType    uint32 `protobuf:"varint,6,opt,name=RepoType" json:"RepoType,omitempty"`
	FileSize    uint64 `protobuf:"varint,7,opt,name=FileSize" json:"FileSize,omitempty"`
}

func (m *V2FileReference) Reset()                    { *m = V2FileReference{} }
func (m *V2FileReference) String() string            { return proto.CompactTextString(m) }
func (*V2FileReference) ProtoMessage()               {}
func (*V2FileReference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *V2FileReference) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *V2FileReference) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *V2FileReference) GetArtefactID() uint64 {
	if m != nil {
		return m.ArtefactID
	}
	return 0
}

func (m *V2FileReference) GetBuildNumber() uint64 {
	if m != nil {
		return m.BuildNumber
	}
	return 0
}

func (m *V2FileReference) GetBase() uint32 {
	if m != nil {
		return m.Base
	}
	return 0
}

func (m *V2FileReference) GetRepoType() uint32 {
	if m != nil {
		return m.RepoType
	}
	return 0
}

func (m *V2FileReference) GetFileSize() uint64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

// a database proto
type ActiveUpdate struct {
	ID               uint64                      `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ModuleID         uint64                      `protobuf:"varint,2,opt,name=ModuleID" json:"ModuleID,omitempty"`
	Created          uint32                      `protobuf:"varint,3,opt,name=Created" json:"Created,omitempty"`
	BuildNumber      uint32                      `protobuf:"varint,4,opt,name=BuildNumber" json:"BuildNumber,omitempty"`
	Repository       uint64                      `protobuf:"varint,5,opt,name=Repository" json:"Repository,omitempty"`
	RequestedBy      string                      `protobuf:"bytes,6,opt,name=RequestedBy" json:"RequestedBy,omitempty"`
	Context          []byte                      `protobuf:"bytes,7,opt,name=Context,proto3" json:"Context,omitempty"`
	Completed        uint32                      `protobuf:"varint,8,opt,name=Completed" json:"Completed,omitempty"`
	GitRepo          *gitserver.SourceRepository `protobuf:"bytes,9,opt,name=GitRepo" json:"GitRepo,omitempty"`
	ServiceTriggered bool                        `protobuf:"varint,10,opt,name=ServiceTriggered" json:"ServiceTriggered,omitempty"`
}

func (m *ActiveUpdate) Reset()                    { *m = ActiveUpdate{} }
func (m *ActiveUpdate) String() string            { return proto.CompactTextString(m) }
func (*ActiveUpdate) ProtoMessage()               {}
func (*ActiveUpdate) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *ActiveUpdate) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *ActiveUpdate) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *ActiveUpdate) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *ActiveUpdate) GetBuildNumber() uint32 {
	if m != nil {
		return m.BuildNumber
	}
	return 0
}

func (m *ActiveUpdate) GetRepository() uint64 {
	if m != nil {
		return m.Repository
	}
	return 0
}

func (m *ActiveUpdate) GetRequestedBy() string {
	if m != nil {
		return m.RequestedBy
	}
	return ""
}

func (m *ActiveUpdate) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *ActiveUpdate) GetCompleted() uint32 {
	if m != nil {
		return m.Completed
	}
	return 0
}

func (m *ActiveUpdate) GetGitRepo() *gitserver.SourceRepository {
	if m != nil {
		return m.GitRepo
	}
	return nil
}

func (m *ActiveUpdate) GetServiceTriggered() bool {
	if m != nil {
		return m.ServiceTriggered
	}
	return false
}

// a database proto (a tracker)
type Tracker struct {
	ID            uint64        `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	State         uint32        `protobuf:"varint,2,opt,name=State" json:"State,omitempty"`
	FD            uint32        `protobuf:"varint,3,opt,name=FD" json:"FD,omitempty"`
	ModuleID      uint64        `protobuf:"varint,4,opt,name=ModuleID" json:"ModuleID,omitempty"`
	ActiveUpdate  *ActiveUpdate `protobuf:"bytes,5,opt,name=ActiveUpdate" json:"ActiveUpdate,omitempty"`
	Context       []byte        `protobuf:"bytes,6,opt,name=Context,proto3" json:"Context,omitempty"`
	UserID        string        `protobuf:"bytes,7,opt,name=UserID" json:"UserID,omitempty"`
	Created       uint32        `protobuf:"varint,8,opt,name=Created" json:"Created,omitempty"`
	Started       uint32        `protobuf:"varint,9,opt,name=Started" json:"Started,omitempty"`
	LastReply     uint32        `protobuf:"varint,10,opt,name=LastReply" json:"LastReply,omitempty"`
	ActualAddress uint64        `protobuf:"varint,11,opt,name=ActualAddress" json:"ActualAddress,omitempty"`
}

func (m *Tracker) Reset()                    { *m = Tracker{} }
func (m *Tracker) String() string            { return proto.CompactTextString(m) }
func (*Tracker) ProtoMessage()               {}
func (*Tracker) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Tracker) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Tracker) GetState() uint32 {
	if m != nil {
		return m.State
	}
	return 0
}

func (m *Tracker) GetFD() uint32 {
	if m != nil {
		return m.FD
	}
	return 0
}

func (m *Tracker) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *Tracker) GetActiveUpdate() *ActiveUpdate {
	if m != nil {
		return m.ActiveUpdate
	}
	return nil
}

func (m *Tracker) GetContext() []byte {
	if m != nil {
		return m.Context
	}
	return nil
}

func (m *Tracker) GetUserID() string {
	if m != nil {
		return m.UserID
	}
	return ""
}

func (m *Tracker) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Tracker) GetStarted() uint32 {
	if m != nil {
		return m.Started
	}
	return 0
}

func (m *Tracker) GetLastReply() uint32 {
	if m != nil {
		return m.LastReply
	}
	return 0
}

func (m *Tracker) GetActualAddress() uint64 {
	if m != nil {
		return m.ActualAddress
	}
	return 0
}

// a database proto - an "Upgrade" might have multiple attempts, one of these
// protos for each attempt
type UpdateInfo struct {
	ID            uint64        `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	UpgradeID     uint64        `protobuf:"varint,2,opt,name=UpgradeID" json:"UpgradeID,omitempty"`
	FirstPacket   uint32        `protobuf:"varint,3,opt,name=FirstPacket" json:"FirstPacket,omitempty"`
	FirstResponse uint32        `protobuf:"varint,4,opt,name=FirstResponse" json:"FirstResponse,omitempty"`
	LastPacket    uint32        `protobuf:"varint,5,opt,name=LastPacket" json:"LastPacket,omitempty"`
	LastResponse  uint32        `protobuf:"varint,6,opt,name=LastResponse" json:"LastResponse,omitempty"`
	Result        UpgradeResult `protobuf:"varint,7,opt,name=Result,enum=scupdate.UpgradeResult" json:"Result,omitempty"`
	SizeBytes     uint32        `protobuf:"varint,8,opt,name=SizeBytes" json:"SizeBytes,omitempty"`
	DoneBytes     uint32        `protobuf:"varint,9,opt,name=DoneBytes" json:"DoneBytes,omitempty"`
	ErrorCode     uint32        `protobuf:"varint,10,opt,name=ErrorCode" json:"ErrorCode,omitempty"`
	ErrorMessage  string        `protobuf:"bytes,11,opt,name=ErrorMessage" json:"ErrorMessage,omitempty"`
	Occured       uint32        `protobuf:"varint,12,opt,name=Occured" json:"Occured,omitempty"`
}

func (m *UpdateInfo) Reset()                    { *m = UpdateInfo{} }
func (m *UpdateInfo) String() string            { return proto.CompactTextString(m) }
func (*UpdateInfo) ProtoMessage()               {}
func (*UpdateInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UpdateInfo) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UpdateInfo) GetUpgradeID() uint64 {
	if m != nil {
		return m.UpgradeID
	}
	return 0
}

func (m *UpdateInfo) GetFirstPacket() uint32 {
	if m != nil {
		return m.FirstPacket
	}
	return 0
}

func (m *UpdateInfo) GetFirstResponse() uint32 {
	if m != nil {
		return m.FirstResponse
	}
	return 0
}

func (m *UpdateInfo) GetLastPacket() uint32 {
	if m != nil {
		return m.LastPacket
	}
	return 0
}

func (m *UpdateInfo) GetLastResponse() uint32 {
	if m != nil {
		return m.LastResponse
	}
	return 0
}

func (m *UpdateInfo) GetResult() UpgradeResult {
	if m != nil {
		return m.Result
	}
	return UpgradeResult_PENDING
}

func (m *UpdateInfo) GetSizeBytes() uint32 {
	if m != nil {
		return m.SizeBytes
	}
	return 0
}

func (m *UpdateInfo) GetDoneBytes() uint32 {
	if m != nil {
		return m.DoneBytes
	}
	return 0
}

func (m *UpdateInfo) GetErrorCode() uint32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *UpdateInfo) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

func (m *UpdateInfo) GetOccured() uint32 {
	if m != nil {
		return m.Occured
	}
	return 0
}

type UpdateRequest struct {
	ModuleID    uint64 `protobuf:"varint,1,opt,name=ModuleID" json:"ModuleID,omitempty"`
	BuildNumber uint32 `protobuf:"varint,2,opt,name=BuildNumber" json:"BuildNumber,omitempty"`
	Repository  uint32 `protobuf:"varint,3,opt,name=Repository" json:"Repository,omitempty"`
}

func (m *UpdateRequest) Reset()                    { *m = UpdateRequest{} }
func (m *UpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateRequest) ProtoMessage()               {}
func (*UpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *UpdateRequest) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *UpdateRequest) GetBuildNumber() uint32 {
	if m != nil {
		return m.BuildNumber
	}
	return 0
}

func (m *UpdateRequest) GetRepository() uint32 {
	if m != nil {
		return m.Repository
	}
	return 0
}

type BlobUpdateRequest struct {
	ModuleID      uint64   `protobuf:"varint,1,opt,name=ModuleID" json:"ModuleID,omitempty"`
	Blob          []byte   `protobuf:"bytes,2,opt,name=Blob,proto3" json:"Blob,omitempty"`
	IsLoader      bool     `protobuf:"varint,3,opt,name=IsLoader" json:"IsLoader,omitempty"`
	Address       uint32   `protobuf:"varint,4,opt,name=Address" json:"Address,omitempty"`
	Prerequisites []*Match `protobuf:"bytes,5,rep,name=Prerequisites" json:"Prerequisites,omitempty"`
}

func (m *BlobUpdateRequest) Reset()                    { *m = BlobUpdateRequest{} }
func (m *BlobUpdateRequest) String() string            { return proto.CompactTextString(m) }
func (*BlobUpdateRequest) ProtoMessage()               {}
func (*BlobUpdateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *BlobUpdateRequest) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *BlobUpdateRequest) GetBlob() []byte {
	if m != nil {
		return m.Blob
	}
	return nil
}

func (m *BlobUpdateRequest) GetIsLoader() bool {
	if m != nil {
		return m.IsLoader
	}
	return false
}

func (m *BlobUpdateRequest) GetAddress() uint32 {
	if m != nil {
		return m.Address
	}
	return 0
}

func (m *BlobUpdateRequest) GetPrerequisites() []*Match {
	if m != nil {
		return m.Prerequisites
	}
	return nil
}

// check if a given version exists at a specific address, if not decline update
type Match struct {
	MinimumVersion uint64 `protobuf:"varint,1,opt,name=MinimumVersion" json:"MinimumVersion,omitempty"`
	MaximumVersion uint64 `protobuf:"varint,2,opt,name=MaximumVersion" json:"MaximumVersion,omitempty"`
	BaseAddress    uint32 `protobuf:"varint,3,opt,name=BaseAddress" json:"BaseAddress,omitempty"`
	Repository     uint64 `protobuf:"varint,4,opt,name=Repository" json:"Repository,omitempty"`
	NotMatch       bool   `protobuf:"varint,5,opt,name=NotMatch" json:"NotMatch,omitempty"`
	Alternative    *Match `protobuf:"bytes,6,opt,name=Alternative" json:"Alternative,omitempty"`
}

func (m *Match) Reset()                    { *m = Match{} }
func (m *Match) String() string            { return proto.CompactTextString(m) }
func (*Match) ProtoMessage()               {}
func (*Match) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *Match) GetMinimumVersion() uint64 {
	if m != nil {
		return m.MinimumVersion
	}
	return 0
}

func (m *Match) GetMaximumVersion() uint64 {
	if m != nil {
		return m.MaximumVersion
	}
	return 0
}

func (m *Match) GetBaseAddress() uint32 {
	if m != nil {
		return m.BaseAddress
	}
	return 0
}

func (m *Match) GetRepository() uint64 {
	if m != nil {
		return m.Repository
	}
	return 0
}

func (m *Match) GetNotMatch() bool {
	if m != nil {
		return m.NotMatch
	}
	return false
}

func (m *Match) GetAlternative() *Match {
	if m != nil {
		return m.Alternative
	}
	return nil
}

type UpdateResponse struct {
	UpdateID uint64 `protobuf:"varint,1,opt,name=UpdateID" json:"UpdateID,omitempty"`
}

func (m *UpdateResponse) Reset()                    { *m = UpdateResponse{} }
func (m *UpdateResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateResponse) ProtoMessage()               {}
func (*UpdateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *UpdateResponse) GetUpdateID() uint64 {
	if m != nil {
		return m.UpdateID
	}
	return 0
}

type ComReceived struct {
	Command *singingcat.Command `protobuf:"bytes,1,opt,name=Command" json:"Command,omitempty"`
	Sender  *scweb.Module       `protobuf:"bytes,2,opt,name=Sender" json:"Sender,omitempty"`
}

func (m *ComReceived) Reset()                    { *m = ComReceived{} }
func (m *ComReceived) String() string            { return proto.CompactTextString(m) }
func (*ComReceived) ProtoMessage()               {}
func (*ComReceived) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ComReceived) GetCommand() *singingcat.Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ComReceived) GetSender() *scweb.Module {
	if m != nil {
		return m.Sender
	}
	return nil
}

type UpdateStatus struct {
	ID        uint64                `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Created   uint32                `protobuf:"varint,2,opt,name=Created" json:"Created,omitempty"`
	Status    uint32                `protobuf:"varint,3,opt,name=Status" json:"Status,omitempty"`
	End       uint32                `protobuf:"varint,4,opt,name=End" json:"End,omitempty"`
	LastReply uint32                `protobuf:"varint,5,opt,name=LastReply" json:"LastReply,omitempty"`
	Finished  bool                  `protobuf:"varint,6,opt,name=Finished" json:"Finished,omitempty"`
	Failed    bool                  `protobuf:"varint,7,opt,name=Failed" json:"Failed,omitempty"`
	ErrorMsg  string                `protobuf:"bytes,8,opt,name=ErrorMsg" json:"ErrorMsg,omitempty"`
	TotalSize uint64                `protobuf:"varint,9,opt,name=TotalSize" json:"TotalSize,omitempty"`
	TotalSent uint64                `protobuf:"varint,10,opt,name=TotalSent" json:"TotalSent,omitempty"`
	Module    *singingcat.ModuleRef `protobuf:"bytes,11,opt,name=Module" json:"Module,omitempty"`
	Tracker   *Tracker              `protobuf:"bytes,12,opt,name=Tracker" json:"Tracker,omitempty"`
}

func (m *UpdateStatus) Reset()                    { *m = UpdateStatus{} }
func (m *UpdateStatus) String() string            { return proto.CompactTextString(m) }
func (*UpdateStatus) ProtoMessage()               {}
func (*UpdateStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *UpdateStatus) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UpdateStatus) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *UpdateStatus) GetStatus() uint32 {
	if m != nil {
		return m.Status
	}
	return 0
}

func (m *UpdateStatus) GetEnd() uint32 {
	if m != nil {
		return m.End
	}
	return 0
}

func (m *UpdateStatus) GetLastReply() uint32 {
	if m != nil {
		return m.LastReply
	}
	return 0
}

func (m *UpdateStatus) GetFinished() bool {
	if m != nil {
		return m.Finished
	}
	return false
}

func (m *UpdateStatus) GetFailed() bool {
	if m != nil {
		return m.Failed
	}
	return false
}

func (m *UpdateStatus) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

func (m *UpdateStatus) GetTotalSize() uint64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *UpdateStatus) GetTotalSent() uint64 {
	if m != nil {
		return m.TotalSent
	}
	return 0
}

func (m *UpdateStatus) GetModule() *singingcat.ModuleRef {
	if m != nil {
		return m.Module
	}
	return nil
}

func (m *UpdateStatus) GetTracker() *Tracker {
	if m != nil {
		return m.Tracker
	}
	return nil
}

type UpdateStatusList struct {
	Status []*UpdateStatus `protobuf:"bytes,1,rep,name=Status" json:"Status,omitempty"`
}

func (m *UpdateStatusList) Reset()                    { *m = UpdateStatusList{} }
func (m *UpdateStatusList) String() string            { return proto.CompactTextString(m) }
func (*UpdateStatusList) ProtoMessage()               {}
func (*UpdateStatusList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *UpdateStatusList) GetStatus() []*UpdateStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type FirmwareInfo struct {
	Module     *singingcat.ModuleRef `protobuf:"bytes,1,opt,name=Module" json:"Module,omitempty"`
	Repository uint64                `protobuf:"varint,2,opt,name=Repository" json:"Repository,omitempty"`
	Version    uint32                `protobuf:"varint,3,opt,name=Version" json:"Version,omitempty"`
}

func (m *FirmwareInfo) Reset()                    { *m = FirmwareInfo{} }
func (m *FirmwareInfo) String() string            { return proto.CompactTextString(m) }
func (*FirmwareInfo) ProtoMessage()               {}
func (*FirmwareInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *FirmwareInfo) GetModule() *singingcat.ModuleRef {
	if m != nil {
		return m.Module
	}
	return nil
}

func (m *FirmwareInfo) GetRepository() uint64 {
	if m != nil {
		return m.Repository
	}
	return 0
}

func (m *FirmwareInfo) GetVersion() uint32 {
	if m != nil {
		return m.Version
	}
	return 0
}

// a history of upgrades and outcomes for a given module
type HistoryList struct {
	Histories []*History `protobuf:"bytes,1,rep,name=Histories" json:"Histories,omitempty"`
}

func (m *HistoryList) Reset()                    { *m = HistoryList{} }
func (m *HistoryList) String() string            { return proto.CompactTextString(m) }
func (*HistoryList) ProtoMessage()               {}
func (*HistoryList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *HistoryList) GetHistories() []*History {
	if m != nil {
		return m.Histories
	}
	return nil
}

// one upgrade
type History struct {
	Update *ActiveUpdate `protobuf:"bytes,1,opt,name=Update" json:"Update,omitempty"`
	Infos  []*UpdateInfo `protobuf:"bytes,2,rep,name=Infos" json:"Infos,omitempty"`
}

func (m *History) Reset()                    { *m = History{} }
func (m *History) String() string            { return proto.CompactTextString(m) }
func (*History) ProtoMessage()               {}
func (*History) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *History) GetUpdate() *ActiveUpdate {
	if m != nil {
		return m.Update
	}
	return nil
}

func (m *History) GetInfos() []*UpdateInfo {
	if m != nil {
		return m.Infos
	}
	return nil
}

type UpgradeRepoRequest struct {
	Repository uint32 `protobuf:"varint,1,opt,name=Repository" json:"Repository,omitempty"`
}

func (m *UpgradeRepoRequest) Reset()                    { *m = UpgradeRepoRequest{} }
func (m *UpgradeRepoRequest) String() string            { return proto.CompactTextString(m) }
func (*UpgradeRepoRequest) ProtoMessage()               {}
func (*UpgradeRepoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *UpgradeRepoRequest) GetRepository() uint32 {
	if m != nil {
		return m.Repository
	}
	return 0
}

type UpdateFromRepoRequest struct {
	ModuleID       uint64   `protobuf:"varint,1,opt,name=ModuleID" json:"ModuleID,omitempty"`
	BuildNumber    uint64   `protobuf:"varint,2,opt,name=BuildNumber" json:"BuildNumber,omitempty"`
	Repository     uint64   `protobuf:"varint,3,opt,name=Repository" json:"Repository,omitempty"`
	IsLoader       bool     `protobuf:"varint,4,opt,name=IsLoader" json:"IsLoader,omitempty"`
	Address        uint32   `protobuf:"varint,5,opt,name=Address" json:"Address,omitempty"`
	FilenameInRepo string   `protobuf:"bytes,6,opt,name=FilenameInRepo" json:"FilenameInRepo,omitempty"`
	Prerequisites  []*Match `protobuf:"bytes,7,rep,name=Prerequisites" json:"Prerequisites,omitempty"`
}

func (m *UpdateFromRepoRequest) Reset()                    { *m = UpdateFromRepoRequest{} }
func (m *UpdateFromRepoRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateFromRepoRequest) ProtoMessage()               {}
func (*UpdateFromRepoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *UpdateFromRepoRequest) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *UpdateFromRepoRequest) GetBuildNumber() uint64 {
	if m != nil {
		return m.BuildNumber
	}
	return 0
}

func (m *UpdateFromRepoRequest) GetRepository() uint64 {
	if m != nil {
		return m.Repository
	}
	return 0
}

func (m *UpdateFromRepoRequest) GetIsLoader() bool {
	if m != nil {
		return m.IsLoader
	}
	return false
}

func (m *UpdateFromRepoRequest) GetAddress() uint32 {
	if m != nil {
		return m.Address
	}
	return 0
}

func (m *UpdateFromRepoRequest) GetFilenameInRepo() string {
	if m != nil {
		return m.FilenameInRepo
	}
	return ""
}

func (m *UpdateFromRepoRequest) GetPrerequisites() []*Match {
	if m != nil {
		return m.Prerequisites
	}
	return nil
}

// history of updates for a module
type UpdateLog struct {
	ID          uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	ModuleID    uint64 `protobuf:"varint,2,opt,name=ModuleID" json:"ModuleID,omitempty"`
	BuildNumber uint64 `protobuf:"varint,3,opt,name=BuildNumber" json:"BuildNumber,omitempty"`
	Repository  uint64 `protobuf:"varint,4,opt,name=Repository" json:"Repository,omitempty"`
	Timestamp   uint32 `protobuf:"varint,5,opt,name=Timestamp" json:"Timestamp,omitempty"`
}

func (m *UpdateLog) Reset()                    { *m = UpdateLog{} }
func (m *UpdateLog) String() string            { return proto.CompactTextString(m) }
func (*UpdateLog) ProtoMessage()               {}
func (*UpdateLog) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *UpdateLog) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UpdateLog) GetModuleID() uint64 {
	if m != nil {
		return m.ModuleID
	}
	return 0
}

func (m *UpdateLog) GetBuildNumber() uint64 {
	if m != nil {
		return m.BuildNumber
	}
	return 0
}

func (m *UpdateLog) GetRepository() uint64 {
	if m != nil {
		return m.Repository
	}
	return 0
}

func (m *UpdateLog) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func init() {
	proto.RegisterType((*V2UpdateRequest)(nil), "scupdate.V2UpdateRequest")
	proto.RegisterType((*V2Status)(nil), "scupdate.V2Status")
	proto.RegisterType((*V2FileReference)(nil), "scupdate.V2FileReference")
	proto.RegisterType((*ActiveUpdate)(nil), "scupdate.ActiveUpdate")
	proto.RegisterType((*Tracker)(nil), "scupdate.Tracker")
	proto.RegisterType((*UpdateInfo)(nil), "scupdate.UpdateInfo")
	proto.RegisterType((*UpdateRequest)(nil), "scupdate.UpdateRequest")
	proto.RegisterType((*BlobUpdateRequest)(nil), "scupdate.BlobUpdateRequest")
	proto.RegisterType((*Match)(nil), "scupdate.Match")
	proto.RegisterType((*UpdateResponse)(nil), "scupdate.UpdateResponse")
	proto.RegisterType((*ComReceived)(nil), "scupdate.ComReceived")
	proto.RegisterType((*UpdateStatus)(nil), "scupdate.UpdateStatus")
	proto.RegisterType((*UpdateStatusList)(nil), "scupdate.UpdateStatusList")
	proto.RegisterType((*FirmwareInfo)(nil), "scupdate.FirmwareInfo")
	proto.RegisterType((*HistoryList)(nil), "scupdate.HistoryList")
	proto.RegisterType((*History)(nil), "scupdate.History")
	proto.RegisterType((*UpgradeRepoRequest)(nil), "scupdate.UpgradeRepoRequest")
	proto.RegisterType((*UpdateFromRepoRequest)(nil), "scupdate.UpdateFromRepoRequest")
	proto.RegisterType((*UpdateLog)(nil), "scupdate.UpdateLog")
	proto.RegisterEnum("scupdate.UpgradeResult", UpgradeResult_name, UpgradeResult_value)
	proto.RegisterEnum("scupdate.UpdateFlags", UpdateFlags_name, UpdateFlags_value)
	proto.RegisterEnum("scupdate.V2StatusIndicator", V2StatusIndicator_name, V2StatusIndicator_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SCUpdateService service

type SCUpdateServiceClient interface {
	// called by scserver with updates from module re streams
	StreamCommandReceived(ctx context.Context, in *ComReceived, opts ...grpc.CallOption) (*common.Void, error)
	// DEPRECATED see UpdateModuleFromRepo update a module
	UpdateModule(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
	// DEPRECATED
	UpdateModuleFromBlob(ctx context.Context, in *BlobUpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
	// misnomer, this actually GETS an update status for a module
	UpdateStatus(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*UpdateStatusList, error)
	// called after a statusupdate/firmware information was received
	CheckFirmware(ctx context.Context, in *FirmwareInfo, opts ...grpc.CallOption) (*common.Void, error)
	// abort a current firmware update
	AbortUpdate(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error)
	// list all current updates
	ListUpdates(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*UpdateStatusList, error)
	// list recent update history for a given module
	HistoryForModule(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*HistoryList, error)
	// DEPRECATED
	UpgradeRepo(ctx context.Context, in *UpgradeRepoRequest, opts ...grpc.CallOption) (*common.Void, error)
	// cancel all active upgrades
	CancelAll(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error)
	// callback for stream setup commands
	SCApplyCallback(ctx context.Context, in *scapply.CallbackResult, opts ...grpc.CallOption) (*common.Void, error)
	// update from any file in any repo with more details
	UpdateModuleFromRepo(ctx context.Context, in *UpdateFromRepoRequest, opts ...grpc.CallOption) (*UpdateResponse, error)
	// restart an update
	RestartUpdate(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error)
}

type sCUpdateServiceClient struct {
	cc *grpc.ClientConn
}

func NewSCUpdateServiceClient(cc *grpc.ClientConn) SCUpdateServiceClient {
	return &sCUpdateServiceClient{cc}
}

func (c *sCUpdateServiceClient) StreamCommandReceived(ctx context.Context, in *ComReceived, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/StreamCommandReceived", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) UpdateModule(ctx context.Context, in *UpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	out := new(UpdateResponse)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/UpdateModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) UpdateModuleFromBlob(ctx context.Context, in *BlobUpdateRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	out := new(UpdateResponse)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/UpdateModuleFromBlob", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) UpdateStatus(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*UpdateStatusList, error) {
	out := new(UpdateStatusList)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/UpdateStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) CheckFirmware(ctx context.Context, in *FirmwareInfo, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/CheckFirmware", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) AbortUpdate(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/AbortUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) ListUpdates(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*UpdateStatusList, error) {
	out := new(UpdateStatusList)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/ListUpdates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) HistoryForModule(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*HistoryList, error) {
	out := new(HistoryList)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/HistoryForModule", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) UpgradeRepo(ctx context.Context, in *UpgradeRepoRequest, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/UpgradeRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) CancelAll(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/CancelAll", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) SCApplyCallback(ctx context.Context, in *scapply.CallbackResult, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/SCApplyCallback", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) UpdateModuleFromRepo(ctx context.Context, in *UpdateFromRepoRequest, opts ...grpc.CallOption) (*UpdateResponse, error) {
	out := new(UpdateResponse)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/UpdateModuleFromRepo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCUpdateServiceClient) RestartUpdate(ctx context.Context, in *singingcat.ModuleRef, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scupdate.SCUpdateService/RestartUpdate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SCUpdateService service

type SCUpdateServiceServer interface {
	// called by scserver with updates from module re streams
	StreamCommandReceived(context.Context, *ComReceived) (*common.Void, error)
	// DEPRECATED see UpdateModuleFromRepo update a module
	UpdateModule(context.Context, *UpdateRequest) (*UpdateResponse, error)
	// DEPRECATED
	UpdateModuleFromBlob(context.Context, *BlobUpdateRequest) (*UpdateResponse, error)
	// misnomer, this actually GETS an update status for a module
	UpdateStatus(context.Context, *singingcat.ModuleRef) (*UpdateStatusList, error)
	// called after a statusupdate/firmware information was received
	CheckFirmware(context.Context, *FirmwareInfo) (*common.Void, error)
	// abort a current firmware update
	AbortUpdate(context.Context, *singingcat.ModuleRef) (*common.Void, error)
	// list all current updates
	ListUpdates(context.Context, *common.Void) (*UpdateStatusList, error)
	// list recent update history for a given module
	HistoryForModule(context.Context, *singingcat.ModuleRef) (*HistoryList, error)
	// DEPRECATED
	UpgradeRepo(context.Context, *UpgradeRepoRequest) (*common.Void, error)
	// cancel all active upgrades
	CancelAll(context.Context, *common.Void) (*common.Void, error)
	// callback for stream setup commands
	SCApplyCallback(context.Context, *scapply.CallbackResult) (*common.Void, error)
	// update from any file in any repo with more details
	UpdateModuleFromRepo(context.Context, *UpdateFromRepoRequest) (*UpdateResponse, error)
	// restart an update
	RestartUpdate(context.Context, *singingcat.ModuleRef) (*common.Void, error)
}

func RegisterSCUpdateServiceServer(s *grpc.Server, srv SCUpdateServiceServer) {
	s.RegisterService(&_SCUpdateService_serviceDesc, srv)
}

func _SCUpdateService_StreamCommandReceived_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ComReceived)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).StreamCommandReceived(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/StreamCommandReceived",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).StreamCommandReceived(ctx, req.(*ComReceived))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_UpdateModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).UpdateModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/UpdateModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).UpdateModule(ctx, req.(*UpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_UpdateModuleFromBlob_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BlobUpdateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).UpdateModuleFromBlob(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/UpdateModuleFromBlob",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).UpdateModuleFromBlob(ctx, req.(*BlobUpdateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_UpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).UpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/UpdateStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).UpdateStatus(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_CheckFirmware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FirmwareInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).CheckFirmware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/CheckFirmware",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).CheckFirmware(ctx, req.(*FirmwareInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_AbortUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).AbortUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/AbortUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).AbortUpdate(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_ListUpdates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).ListUpdates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/ListUpdates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).ListUpdates(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_HistoryForModule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).HistoryForModule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/HistoryForModule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).HistoryForModule(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_UpgradeRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpgradeRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).UpgradeRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/UpgradeRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).UpgradeRepo(ctx, req.(*UpgradeRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_CancelAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).CancelAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/CancelAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).CancelAll(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_SCApplyCallback_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(scapply.CallbackResult)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).SCApplyCallback(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/SCApplyCallback",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).SCApplyCallback(ctx, req.(*scapply.CallbackResult))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_UpdateModuleFromRepo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateFromRepoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).UpdateModuleFromRepo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/UpdateModuleFromRepo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).UpdateModuleFromRepo(ctx, req.(*UpdateFromRepoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCUpdateService_RestartUpdate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCUpdateServiceServer).RestartUpdate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scupdate.SCUpdateService/RestartUpdate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCUpdateServiceServer).RestartUpdate(ctx, req.(*singingcat.ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

var _SCUpdateService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scupdate.SCUpdateService",
	HandlerType: (*SCUpdateServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "StreamCommandReceived",
			Handler:    _SCUpdateService_StreamCommandReceived_Handler,
		},
		{
			MethodName: "UpdateModule",
			Handler:    _SCUpdateService_UpdateModule_Handler,
		},
		{
			MethodName: "UpdateModuleFromBlob",
			Handler:    _SCUpdateService_UpdateModuleFromBlob_Handler,
		},
		{
			MethodName: "UpdateStatus",
			Handler:    _SCUpdateService_UpdateStatus_Handler,
		},
		{
			MethodName: "CheckFirmware",
			Handler:    _SCUpdateService_CheckFirmware_Handler,
		},
		{
			MethodName: "AbortUpdate",
			Handler:    _SCUpdateService_AbortUpdate_Handler,
		},
		{
			MethodName: "ListUpdates",
			Handler:    _SCUpdateService_ListUpdates_Handler,
		},
		{
			MethodName: "HistoryForModule",
			Handler:    _SCUpdateService_HistoryForModule_Handler,
		},
		{
			MethodName: "UpgradeRepo",
			Handler:    _SCUpdateService_UpgradeRepo_Handler,
		},
		{
			MethodName: "CancelAll",
			Handler:    _SCUpdateService_CancelAll_Handler,
		},
		{
			MethodName: "SCApplyCallback",
			Handler:    _SCUpdateService_SCApplyCallback_Handler,
		},
		{
			MethodName: "UpdateModuleFromRepo",
			Handler:    _SCUpdateService_UpdateModuleFromRepo_Handler,
		},
		{
			MethodName: "RestartUpdate",
			Handler:    _SCUpdateService_RestartUpdate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "golang.singingcat.net/apis/scupdate/scupdate.proto",
}

func init() { proto.RegisterFile("golang.singingcat.net/apis/scupdate/scupdate.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 2178 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xbc, 0x58, 0x4f, 0x73, 0x1b, 0x49,
	0x15, 0x8f, 0x64, 0x59, 0x7f, 0x9e, 0x24, 0x5b, 0xee, 0xc4, 0xd9, 0xb1, 0x12, 0xb2, 0x2e, 0xb1,
	0x01, 0x57, 0xc8, 0x2a, 0x8b, 0x48, 0x16, 0xa8, 0xa2, 0x28, 0x46, 0xd2, 0x28, 0x11, 0xc8, 0xb6,
	0xe8, 0x19, 0xe5, 0xaa, 0x6a, 0xcf, 0x74, 0x94, 0xa9, 0x8c, 0x66, 0x66, 0x7b, 0x46, 0xc9, 0x9a,
	0x63, 0x8e, 0x5c, 0x38, 0x52, 0xc5, 0x91, 0x23, 0x27, 0x38, 0xf1, 0x21, 0x38, 0xf2, 0x01, 0xf6,
	0xba, 0x9f, 0x80, 0x33, 0xd5, 0x3d, 0x3d, 0x7f, 0x65, 0x3b, 0x09, 0x07, 0x2e, 0xb6, 0xde, 0xef,
	0xbd, 0xee, 0x7e, 0xfd, 0xeb, 0xf7, 0x7e, 0xdd, 0x12, 0x0c, 0x56, 0x9e, 0x43, 0xdc, 0x55, 0x3f,
	0xb0, 0xdd, 0x95, 0xed, 0xae, 0x4c, 0x12, 0xf6, 0x5d, 0x1a, 0x3e, 0x21, 0xbe, 0x1d, 0x3c, 0x09,
	0xcc, 0x8d, 0x6f, 0x91, 0x90, 0x26, 0x1f, 0xfa, 0x3e, 0xf3, 0x42, 0x0f, 0xd5, 0x63, 0xbb, 0xdb,
	0x97, 0xa3, 0x4d, 0xcf, 0x65, 0xc4, 0x7a, 0xe7, 0x79, 0x56, 0x3a, 0xda, 0xf4, 0xd6, 0x6b, 0xcf,
	0x95, 0xff, 0xa2, 0x91, 0xdd, 0xa7, 0x37, 0xc4, 0xaf, 0xec, 0x30, 0xa0, 0xec, 0x2d, 0x65, 0xe9,
	0x27, 0x39, 0xea, 0xeb, 0x9b, 0x72, 0x4c, 0xb0, 0xcc, 0x47, 0x39, 0xee, 0xab, 0x1b, 0xf7, 0x46,
	0x7c, 0xdf, 0xb9, 0x8c, 0xff, 0xcb, 0x11, 0x8f, 0x6f, 0x1c, 0xf1, 0x8e, 0x5e, 0x44, 0x7f, 0xa3,
	0xe8, 0xde, 0x77, 0x25, 0xd8, 0x7f, 0x39, 0x58, 0x08, 0x2a, 0x30, 0xfd, 0x66, 0x43, 0x83, 0x10,
	0xed, 0x41, 0x79, 0x3a, 0x56, 0x4a, 0xc7, 0xa5, 0x93, 0x0a, 0x2e, 0x4f, 0xc7, 0xe8, 0x0b, 0xa8,
	0x9f, 0x7a, 0xd6, 0xc6, 0xa1, 0xd3, 0xb1, 0x52, 0xe6, 0xe8, 0xb0, 0xfe, 0xb7, 0xf7, 0x47, 0x95,
	0x90, 0x6d, 0x28, 0x4e, 0x3c, 0x48, 0x81, 0xda, 0x88, 0x51, 0x12, 0x52, 0x4b, 0xd9, 0x39, 0x2e,
	0x9d, 0xb4, 0x71, 0x6c, 0xa2, 0x63, 0x68, 0x0e, 0x37, 0xb6, 0x63, 0x9d, 0x6d, 0xd6, 0x17, 0x94,
	0x29, 0x15, 0x31, 0x71, 0x16, 0x42, 0x0f, 0x00, 0x30, 0xf5, 0xbd, 0xc0, 0x0e, 0x3d, 0x76, 0xa9,
	0xec, 0x8a, 0x80, 0x0c, 0xc2, 0x67, 0x90, 0xc9, 0x51, 0x6b, 0x78, 0xa9, 0x54, 0x8f, 0x4b, 0x27,
	0x0d, 0x9c, 0x85, 0xc4, 0xea, 0x9e, 0x1b, 0xd2, 0x6f, 0x43, 0xa5, 0x76, 0x5c, 0x3a, 0x69, 0xe1,
	0xd8, 0xec, 0xfd, 0xa7, 0x0a, 0xf5, 0x97, 0x03, 0x3d, 0x24, 0xe1, 0x26, 0xd8, 0xda, 0x9a, 0x0d,
	0xed, 0xdc, 0xde, 0xc5, 0xfe, 0x9a, 0x83, 0xa3, 0x7e, 0x52, 0x2e, 0x05, 0x72, 0x86, 0x27, 0x7f,
	0x79, 0x7f, 0x54, 0xdd, 0xd8, 0x6e, 0xf8, 0xf5, 0xd3, 0xbf, 0xbe, 0x3f, 0x42, 0x05, 0x77, 0xdf,
	0xb6, 0x12, 0x6a, 0xf2, 0x33, 0x23, 0x15, 0xda, 0xa3, 0x0d, 0x63, 0xd4, 0x0d, 0xa3, 0x5c, 0x04,
	0x4b, 0x7b, 0x83, 0x7b, 0xd9, 0xa5, 0x22, 0xcf, 0xd4, 0xb5, 0x6c, 0x93, 0x84, 0x1e, 0xc3, 0xf9,
	0x11, 0x9c, 0x86, 0x19, 0x09, 0xc2, 0x91, 0xb7, 0xd6, 0xa9, 0x1b, 0x0a, 0x22, 0xdb, 0x38, 0x0b,
	0xa1, 0x13, 0xd8, 0x1f, 0x6d, 0xd8, 0xc4, 0x66, 0xeb, 0x77, 0x84, 0xd1, 0x21, 0x09, 0xa8, 0x60,
	0xb3, 0x8d, 0x8b, 0x30, 0xea, 0x03, 0xca, 0x40, 0x2f, 0x29, 0x0b, 0x6c, 0xcf, 0x15, 0xcc, 0xb6,
	0xf1, 0x15, 0x1e, 0x7e, 0x44, 0xa3, 0x0d, 0x53, 0x7d, 0x5f, 0x4c, 0x5a, 0x13, 0x71, 0x19, 0x04,
	0x7d, 0x21, 0xb6, 0xa7, 0xfa, 0x7e, 0x3c, 0x55, 0x5d, 0x84, 0xe4, 0x41, 0x9e, 0xdf, 0xc4, 0x76,
	0x28, 0xa6, 0xaf, 0x28, 0xa3, 0xae, 0xc9, 0x2b, 0xaa, 0x21, 0x0e, 0xa3, 0x08, 0xa3, 0x1f, 0xc1,
	0x1e, 0x87, 0xc6, 0x34, 0x30, 0x99, 0xed, 0x87, 0x1e, 0x53, 0x40, 0x04, 0x16, 0x50, 0x74, 0x1f,
	0x1a, 0x9c, 0x00, 0xd5, 0x7c, 0x43, 0x2d, 0xa5, 0x29, 0x42, 0x52, 0x00, 0x75, 0xa1, 0xce, 0x0d,
	0x41, 0x57, 0x4b, 0x38, 0x13, 0x9b, 0xe7, 0x22, 0x03, 0x31, 0x35, 0xa9, 0xfd, 0x96, 0x5a, 0x4a,
	0x3b, 0xe2, 0xaa, 0x00, 0xa3, 0x1e, 0xb4, 0x38, 0x34, 0x26, 0x21, 0x11, 0x33, 0xed, 0x89, 0xb0,
	0x1c, 0xc6, 0x63, 0x26, 0x24, 0x24, 0xce, 0x84, 0xd8, 0xce, 0x86, 0x51, 0x65, 0xff, 0xb8, 0x74,
	0x52, 0xc7, 0x39, 0x4c, 0xec, 0x9e, 0xd8, 0x0e, 0xb5, 0x0c, 0x7b, 0x4d, 0x83, 0x90, 0xac, 0x7d,
	0xa5, 0x13, 0xad, 0x58, 0x80, 0xf9, 0x6c, 0x1a, 0x63, 0x1e, 0x3b, 0xa5, 0x41, 0x40, 0x56, 0x54,
	0x39, 0x10, 0x15, 0x9f, 0xc3, 0xd0, 0x63, 0x38, 0x18, 0x5e, 0x86, 0x34, 0xe0, 0xcb, 0xab, 0xae,
	0x15, 0x31, 0x80, 0xc4, 0x26, 0xb7, 0x1d, 0xa2, 0x41, 0x1c, 0x2f, 0xa0, 0xc6, 0x99, 0x72, 0x5b,
	0xc4, 0xc4, 0x26, 0x3f, 0x39, 0xbe, 0x13, 0x4c, 0x03, 0x1a, 0x11, 0x75, 0x27, 0x3a, 0xb9, 0x1c,
	0x88, 0xbe, 0x82, 0xdb, 0x23, 0x6f, 0xed, 0x3b, 0x34, 0xb4, 0x3d, 0x37, 0xcd, 0xff, 0x50, 0xc4,
	0x5e, 0xe5, 0xea, 0xfd, 0x4b, 0x48, 0x4b, 0xee, 0x5c, 0xb7, 0xfa, 0xaf, 0x0b, 0x75, 0x1e, 0xe0,
	0x92, 0x35, 0x15, 0xad, 0xd7, 0xc0, 0x89, 0xcd, 0x2b, 0x4e, 0x65, 0x21, 0x7d, 0x45, 0xcc, 0x70,
	0x3a, 0x16, 0xdd, 0x52, 0xc1, 0x19, 0xe4, 0x23, 0x64, 0x05, 0x41, 0x25, 0xd3, 0x02, 0xe2, 0x33,
	0x5f, 0x91, 0x0b, 0x8b, 0x71, 0xe9, 0x53, 0x59, 0xed, 0x89, 0x1d, 0x67, 0xa3, 0xdb, 0x7f, 0x88,
	0x2a, 0xbc, 0x82, 0x13, 0xbb, 0xf7, 0xef, 0x32, 0xb4, 0x54, 0x33, 0xb4, 0xdf, 0xd2, 0xa8, 0xad,
	0xaf, 0xda, 0x4a, 0x5e, 0x25, 0xff, 0x57, 0x6d, 0x6c, 0xff, 0xdf, 0xb4, 0x91, 0x37, 0x8f, 0x3c,
	0x39, 0x6a, 0xc9, 0x86, 0x4d, 0x01, 0xf4, 0x0c, 0x6a, 0xcf, 0xed, 0x90, 0x2f, 0x25, 0x9a, 0xb4,
	0x39, 0xb8, 0xd7, 0x4f, 0xaf, 0x35, 0xdd, 0xdb, 0x30, 0x93, 0xa6, 0x79, 0xe0, 0x38, 0x16, 0x3d,
	0x82, 0x8e, 0x4e, 0xd9, 0x5b, 0xdb, 0xa4, 0x06, 0xb3, 0x57, 0x2b, 0xca, 0xa8, 0x25, 0x7a, 0xb7,
	0x8e, 0xb7, 0xf0, 0xde, 0xf7, 0x65, 0xa8, 0x19, 0x8c, 0x98, 0x6f, 0x28, 0xdb, 0x22, 0xf4, 0x0e,
	0xec, 0x72, 0xdd, 0x8b, 0x0a, 0xa3, 0x8d, 0x23, 0x83, 0x47, 0x4d, 0xc6, 0x92, 0xc5, 0xf2, 0x24,
	0x4f, 0x7b, 0xa5, 0x40, 0x3b, 0xc9, 0x1f, 0x99, 0x20, 0xaf, 0x39, 0xb8, 0x9b, 0x2a, 0x6e, 0xd6,
	0x3b, 0x7c, 0x98, 0x53, 0xf6, 0x7d, 0x22, 0x7c, 0x32, 0x30, 0x23, 0xeb, 0xf9, 0x2a, 0xc8, 0x70,
	0x5b, 0xcd, 0x73, 0x7b, 0x17, 0xaa, 0x8b, 0x80, 0xb2, 0xe9, 0x58, 0x90, 0xde, 0xc0, 0xd2, 0xca,
	0xd6, 0x42, 0x3d, 0x5f, 0x0b, 0x0a, 0xd4, 0xf4, 0x90, 0x30, 0xee, 0x69, 0x44, 0x1e, 0x69, 0xc6,
	0x22, 0x87, 0xa9, 0xef, 0x5c, 0x0a, 0x2e, 0xdb, 0x38, 0x05, 0x78, 0x03, 0xab, 0x66, 0xb8, 0x21,
	0x8e, 0x6a, 0x59, 0x8c, 0x06, 0x81, 0x94, 0xc1, 0x3c, 0xd8, 0xfb, 0xd3, 0x0e, 0x40, 0x94, 0xf4,
	0xd4, 0x7d, 0xe5, 0x6d, 0xb1, 0x7d, 0x1f, 0x1a, 0x0b, 0x7f, 0xc5, 0x88, 0x95, 0xd6, 0x6f, 0x0a,
	0xf0, 0x22, 0x9b, 0xd8, 0x2c, 0x08, 0xe7, 0xfc, 0xa8, 0x42, 0x49, 0x7f, 0x16, 0xe2, 0x49, 0x08,
	0x13, 0xd3, 0xc0, 0xf7, 0xdc, 0x80, 0xca, 0x52, 0xce, 0x83, 0xbc, 0x98, 0x79, 0xde, 0x72, 0x9a,
	0xa8, 0x2f, 0x33, 0x48, 0xac, 0xb4, 0xc9, 0x24, 0xd5, 0x54, 0x69, 0x93, 0x39, 0x9e, 0x40, 0x15,
	0xd3, 0x60, 0xe3, 0x44, 0xd5, 0xbc, 0x37, 0xf8, 0x2c, 0x3d, 0x4f, 0x99, 0x70, 0xe4, 0xc6, 0x32,
	0x8c, 0x6f, 0x8d, 0xb7, 0xb0, 0xd0, 0xc4, 0xb8, 0xca, 0x13, 0x80, 0x7b, 0xc7, 0x9e, 0x2b, 0xbd,
	0x11, 0xef, 0x29, 0xc0, 0xbd, 0x42, 0x74, 0x47, 0x9e, 0x45, 0x63, 0xe6, 0x13, 0x60, 0x4b, 0xa6,
	0x9b, 0x57, 0xc8, 0xb4, 0x02, 0xb5, 0x73, 0xd3, 0xdc, 0xf0, 0x2e, 0x68, 0x45, 0xa7, 0x2a, 0xcd,
	0xde, 0xba, 0xf0, 0xf8, 0xc8, 0xd5, 0x72, 0xa9, 0x50, 0xcb, 0x05, 0xa1, 0x28, 0x7f, 0x48, 0x28,
	0xa2, 0x23, 0xca, 0x20, 0xbd, 0xbf, 0x97, 0xe0, 0x60, 0xe8, 0x78, 0x17, 0x1f, 0xbf, 0x26, 0xd7,
	0x4f, 0xc7, 0xbb, 0x10, 0x8b, 0xb5, 0xb0, 0xf8, 0xcc, 0xe3, 0xa7, 0xc1, 0xcc, 0x23, 0x16, 0x65,
	0x62, 0x8d, 0x3a, 0x4e, 0x6c, 0xbe, 0xd5, 0xb8, 0x04, 0xa3, 0xd3, 0x8f, 0x4d, 0xf4, 0x0c, 0xda,
	0x73, 0x46, 0x19, 0xfd, 0x66, 0x63, 0x07, 0x36, 0x27, 0x7a, 0xf7, 0x78, 0xe7, 0xa4, 0x39, 0xd8,
	0x4f, 0x8f, 0xee, 0x94, 0x84, 0xe6, 0x6b, 0x9c, 0x8f, 0xea, 0x7d, 0x5f, 0x82, 0x5d, 0xe1, 0xe0,
	0xcf, 0x81, 0x53, 0xdb, 0xb5, 0xd7, 0x9b, 0x75, 0xfc, 0xbe, 0x88, 0x92, 0x2d, 0xa0, 0x22, 0x8e,
	0x7c, 0x9b, 0x8d, 0x2b, 0xcb, 0xb8, 0x1c, 0x2a, 0xe8, 0x24, 0x01, 0x8d, 0xd3, 0x95, 0x05, 0x9d,
	0x81, 0x0a, 0x74, 0x56, 0xb6, 0x74, 0xb7, 0x0b, 0xf5, 0x33, 0x2f, 0x14, 0xd9, 0x89, 0x42, 0xae,
	0xe3, 0xc4, 0x46, 0x3f, 0x85, 0xa6, 0xea, 0x84, 0x94, 0xb9, 0x84, 0x4b, 0x85, 0xa8, 0xe2, 0x2b,
	0x36, 0x9b, 0x8d, 0xe9, 0x3d, 0x86, 0xbd, 0xf8, 0x60, 0x64, 0x9d, 0x77, 0xa1, 0x2e, 0xfb, 0x35,
	0x39, 0x99, 0xd8, 0xee, 0x99, 0xd0, 0x1c, 0x79, 0xeb, 0xe4, 0x81, 0xf2, 0x25, 0x57, 0xa1, 0xf5,
	0x9a, 0xb8, 0x96, 0x88, 0x6c, 0x0e, 0x6e, 0x67, 0x9f, 0xff, 0xd2, 0x85, 0xe3, 0x18, 0xf4, 0x10,
	0xaa, 0x3a, 0x75, 0x2d, 0x59, 0x46, 0xcd, 0x41, 0xbb, 0x1f, 0x7d, 0x25, 0x88, 0x0e, 0x1e, 0x4b,
	0x27, 0x17, 0xe7, 0x56, 0xb4, 0xe2, 0x35, 0xaf, 0xe7, 0x8c, 0x94, 0x95, 0xf3, 0x52, 0x76, 0x17,
	0xaa, 0x99, 0x57, 0x6e, 0x1b, 0x4b, 0x0b, 0x75, 0x60, 0x47, 0x73, 0x2d, 0x59, 0x1d, 0xfc, 0x63,
	0x5e, 0xda, 0x76, 0x8b, 0xd2, 0x26, 0x6e, 0x64, 0xd7, 0x0e, 0x5e, 0x53, 0x4b, 0xb0, 0x58, 0xc7,
	0x89, 0xcd, 0xd7, 0x88, 0x9e, 0x4d, 0x42, 0x07, 0xea, 0x58, 0x5a, 0x7c, 0x4c, 0xd4, 0x80, 0xc1,
	0x4a, 0x74, 0x7b, 0x03, 0x27, 0x36, 0x5f, 0xcd, 0xf0, 0x42, 0xe2, 0x88, 0x2b, 0x3e, 0x7a, 0x79,
	0xa6, 0x40, 0xea, 0xe5, 0xaf, 0x20, 0xc8, 0x7a, 0xf9, 0x0b, 0xe8, 0x4b, 0xa8, 0x46, 0x04, 0x89,
	0x36, 0x6f, 0x0e, 0x0e, 0xb3, 0x1c, 0x4b, 0xea, 0xe8, 0x2b, 0x2c, 0x83, 0xd0, 0x4f, 0x92, 0x9b,
	0x4d, 0xf4, 0x7d, 0x73, 0x70, 0x90, 0x9e, 0xbf, 0x74, 0xe0, 0x38, 0xa2, 0x37, 0x84, 0x4e, 0x96,
	0xe9, 0x99, 0x1d, 0x84, 0xa8, 0x9f, 0x70, 0x58, 0x12, 0xcd, 0x72, 0x37, 0xab, 0x73, 0x69, 0x6c,
	0xcc, 0x6d, 0xef, 0x1d, 0xb4, 0xe2, 0x47, 0xbb, 0x50, 0xf8, 0x34, 0xdf, 0xd2, 0xc7, 0xe4, 0x9b,
	0xaf, 0xf7, 0xf2, 0x56, 0xbd, 0x2b, 0x50, 0x8b, 0x5b, 0x4a, 0xbe, 0x61, 0xa4, 0xd9, 0xfb, 0x35,
	0x34, 0x5f, 0xd8, 0x01, 0x0f, 0x12, 0x79, 0x3f, 0x81, 0x46, 0x64, 0xda, 0x34, 0x4e, 0x3d, 0xb3,
	0x75, 0x19, 0x89, 0xd3, 0x98, 0x1e, 0x85, 0x9a, 0x44, 0xf9, 0x9e, 0xe5, 0x5d, 0x5d, 0xba, 0xe9,
	0xae, 0xc6, 0x32, 0x0a, 0x3d, 0x82, 0x5d, 0xbe, 0xd7, 0x40, 0x29, 0x8b, 0x75, 0xee, 0x14, 0x29,
	0xe2, 0x4e, 0x1c, 0x85, 0xf4, 0x9e, 0x02, 0x4a, 0xee, 0x07, 0xdf, 0x8b, 0xf5, 0x2f, 0xbf, 0xed,
	0xd2, 0x96, 0x6a, 0xfe, 0xb1, 0x0c, 0x87, 0xd1, 0x5c, 0x13, 0xc6, 0x3b, 0x2e, 0x1d, 0xf9, 0x89,
	0x6a, 0x5d, 0xf9, 0x90, 0x5a, 0x6f, 0xc9, 0x4b, 0xa2, 0xb3, 0x95, 0xeb, 0x75, 0x76, 0x37, 0xaf,
	0xb3, 0xf2, 0x5b, 0x13, 0x7f, 0x3f, 0x4f, 0x5d, 0xf1, 0x72, 0x8b, 0xde, 0x83, 0x05, 0x74, 0x5b,
	0x8f, 0x6b, 0x1f, 0xa5, 0xc7, 0x7f, 0x2e, 0xf1, 0x57, 0x02, 0xf7, 0xcf, 0xbc, 0xd5, 0x27, 0xbd,
	0x80, 0x0b, 0x84, 0xec, 0x7c, 0x88, 0x90, 0x6d, 0xbd, 0xe5, 0xcd, 0x99, 0x7c, 0xed, 0x90, 0x42,
	0x91, 0x00, 0x8f, 0xe6, 0xfc, 0x2e, 0xcd, 0x5c, 0xfe, 0xa8, 0x09, 0xb5, 0xb9, 0x76, 0x36, 0x9e,
	0x9e, 0x3d, 0xef, 0xdc, 0xe2, 0x86, 0x31, 0x3d, 0xd5, 0xce, 0x17, 0x46, 0xa7, 0xc4, 0x0d, 0x7d,
	0x31, 0x1a, 0x69, 0xba, 0xde, 0x29, 0xa3, 0x16, 0xd4, 0xb1, 0xf6, 0x5b, 0x6d, 0x64, 0x68, 0xe3,
	0xce, 0x0e, 0x02, 0xa8, 0x4e, 0xd4, 0xe9, 0x4c, 0x1b, 0x77, 0x2a, 0x8f, 0xbe, 0x2b, 0x41, 0x53,
	0x1e, 0xbc, 0x43, 0x56, 0x01, 0xba, 0x0d, 0xfb, 0x93, 0x99, 0xaa, 0xbf, 0x58, 0x4e, 0x66, 0xea,
	0x73, 0x7d, 0xb9, 0xd0, 0xb5, 0xce, 0x2d, 0xf4, 0x00, 0xba, 0x59, 0x50, 0xd7, 0x8c, 0xe5, 0x4c,
	0x35, 0x34, 0xdd, 0x58, 0xaa, 0xf3, 0x79, 0xa7, 0x84, 0xee, 0x83, 0x92, 0xf3, 0x1b, 0xe7, 0x73,
	0x3e, 0x12, 0x73, 0x6f, 0x19, 0xfd, 0x00, 0x8e, 0xf2, 0x5e, 0x15, 0x1b, 0x89, 0x7b, 0x07, 0xf5,
	0xe0, 0xc1, 0x35, 0x93, 0xc7, 0x31, 0x15, 0x74, 0x04, 0x87, 0xd9, 0x98, 0x39, 0xd6, 0x96, 0x1a,
	0x56, 0x75, 0xad, 0xb3, 0x8b, 0x3e, 0x87, 0x7b, 0x59, 0x17, 0xd6, 0x8c, 0x05, 0x3e, 0xe3, 0x79,
	0x2d, 0xf5, 0xd9, 0xb9, 0xd1, 0xa9, 0x3e, 0xfa, 0x67, 0x09, 0x0e, 0xb6, 0x7e, 0x73, 0x40, 0x6d,
	0x68, 0x2c, 0xce, 0xc6, 0xda, 0x64, 0x7a, 0xa6, 0x8d, 0x3b, 0xb7, 0xd0, 0x01, 0xb4, 0xa7, 0x67,
	0x53, 0x63, 0xaa, 0xce, 0x78, 0x7e, 0x86, 0xd6, 0x29, 0xa1, 0x0e, 0xb4, 0x9e, 0x9f, 0x1b, 0xcb,
	0xd1, 0x02, 0x2f, 0x87, 0x7c, 0xa9, 0x32, 0x3a, 0x84, 0x03, 0x8e, 0x9c, 0xaa, 0xc6, 0xe8, 0xc5,
	0xf4, 0xec, 0xf9, 0x72, 0x32, 0x9d, 0x69, 0x9d, 0x1d, 0x4e, 0x99, 0x6e, 0x60, 0x4d, 0x3d, 0xe5,
	0xb9, 0x2f, 0xe6, 0xcb, 0xf3, 0xdf, 0x75, 0x2a, 0x7c, 0xc2, 0xb1, 0x6a, 0xa8, 0xcb, 0xd1, 0xf9,
	0xe9, 0x7c, 0xa6, 0x19, 0x3c, 0xd3, 0x36, 0x34, 0xb0, 0xa6, 0x6b, 0x86, 0xc1, 0x4f, 0xab, 0xca,
	0xcd, 0xd8, 0x39, 0xee, 0xd4, 0xf8, 0x80, 0xc5, 0x7c, 0xac, 0x1a, 0xda, 0x52, 0x9e, 0x4d, 0x7d,
	0xf0, 0x8f, 0x2a, 0xec, 0xeb, 0x23, 0xa9, 0x82, 0xd1, 0x77, 0x0a, 0xf4, 0x2b, 0x38, 0xd4, 0x43,
	0x46, 0xc9, 0x3a, 0xbe, 0xee, 0xe2, 0xcb, 0xf1, 0x30, 0x2d, 0xea, 0xcc, 0x9d, 0xd9, 0x6d, 0xf5,
	0xe5, 0xcf, 0x7a, 0x2f, 0x3d, 0xdb, 0x42, 0x6a, 0x7c, 0xd5, 0x49, 0x35, 0xfc, 0xac, 0xa8, 0x24,
	0xb2, 0xeb, 0xbb, 0xca, 0xb6, 0x43, 0xde, 0xd7, 0xa7, 0x70, 0x27, 0x3b, 0x05, 0x97, 0x0b, 0xf1,
	0x62, 0xca, 0xfc, 0xc2, 0xb3, 0xf5, 0xfc, 0xba, 0x61, 0x3a, 0xb5, 0x70, 0xf9, 0x5e, 0x2d, 0xdf,
	0xdd, 0xee, 0xd5, 0xb7, 0x82, 0x50, 0xe2, 0x67, 0xd0, 0x1e, 0xbd, 0xa6, 0xe6, 0x9b, 0xf8, 0x5a,
	0x40, 0x19, 0x39, 0xcd, 0x5e, 0x15, 0x05, 0x2e, 0x06, 0xd0, 0x54, 0x2f, 0x3c, 0x16, 0x4a, 0x8d,
	0xbd, 0x66, 0xe1, 0xfc, 0x98, 0x9f, 0x43, 0x93, 0x2f, 0x19, 0x0d, 0x09, 0x50, 0xce, 0x79, 0x63,
	0x8e, 0xbf, 0x81, 0x8e, 0x14, 0xff, 0x89, 0xc7, 0x24, 0xf9, 0xd7, 0xac, 0x78, 0xb8, 0x75, 0x8b,
	0x88, 0x19, 0x7e, 0xc9, 0xfb, 0x34, 0xd1, 0x75, 0x74, 0xff, 0x8a, 0xaf, 0x03, 0x89, 0x68, 0x17,
	0xb2, 0xfe, 0x31, 0x34, 0x46, 0xc4, 0x35, 0xa9, 0xa3, 0x3a, 0x4e, 0x21, 0xe7, 0x7c, 0xe0, 0x2f,
	0x78, 0xbd, 0xa9, 0xbe, 0xef, 0x5c, 0x8e, 0x88, 0xe3, 0x5c, 0x10, 0xf3, 0x8d, 0xa8, 0x90, 0xe8,
	0x77, 0xd7, 0x18, 0x8a, 0x94, 0xa7, 0x30, 0xf2, 0xf7, 0xdb, 0x55, 0x21, 0xd2, 0xfc, 0xbc, 0xc8,
	0x49, 0xe1, 0x7a, 0xb9, 0xa1, 0x32, 0x9e, 0x42, 0x1b, 0x73, 0xd9, 0xfb, 0xa4, 0x13, 0x1a, 0x3e,
	0x84, 0x1f, 0xba, 0x34, 0xcc, 0x46, 0xca, 0x1f, 0x8a, 0x89, 0x6f, 0x07, 0xc9, 0x5a, 0x17, 0x55,
	0xf1, 0xbb, 0xf0, 0xcf, 0xfe, 0x1b, 0x00, 0x00, 0xff, 0xff, 0x13, 0xa1, 0x2d, 0xff, 0x55, 0x17,
	0x00, 0x00,
}
