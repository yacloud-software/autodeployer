// Code generated by protoc-gen-go.
// source: golang.singingcat.net/apis/scserver/scserver.proto
// DO NOT EDIT!

/*
Package scserver is a generated protocol buffer package.

It is generated from these files:
	golang.singingcat.net/apis/scserver/scserver.proto

It has these top-level messages:
	ModuleRef
	Module
	ModuleList
	RouteList
	Route
	CommandDef
	CommandDefList
	ModuleStatus
	FirmwareLocation
	SendResult
	UpdateStatusList
	UpdateStatus
	UpdateStatusRequest
	UpdateReference
	NodeConfig
	Config
	IP
	ActiveNodesRequest
	ActiveNodesResponse
	ActiveNodeStatus
	TCPConnectionList
	TCPConnection
	SendWithResponseRequest
	Response
	SendWithResponseResult
	DirectRouteRequest
	DirectNodeResponse
	DirectRouteResponse
	ListenRequest
	ListenStream
	SequenceNumber
*/
package scserver

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import singingcat "golang.singingcat.net/apis/singingcat"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type ModuleRef struct {
	Node uint32 `protobuf:"varint,1,opt,name=Node" json:"Node,omitempty"`
}

func (m *ModuleRef) Reset()                    { *m = ModuleRef{} }
func (m *ModuleRef) String() string            { return proto.CompactTextString(m) }
func (*ModuleRef) ProtoMessage()               {}
func (*ModuleRef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *ModuleRef) GetNode() uint32 {
	if m != nil {
		return m.Node
	}
	return 0
}

type Module struct {
	Node         uint32 `protobuf:"varint,1,opt,name=Node" json:"Node,omitempty"`
	FriendlyName string `protobuf:"bytes,2,opt,name=FriendlyName" json:"FriendlyName,omitempty"`
}

func (m *Module) Reset()                    { *m = Module{} }
func (m *Module) String() string            { return proto.CompactTextString(m) }
func (*Module) ProtoMessage()               {}
func (*Module) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Module) GetNode() uint32 {
	if m != nil {
		return m.Node
	}
	return 0
}

func (m *Module) GetFriendlyName() string {
	if m != nil {
		return m.FriendlyName
	}
	return ""
}

type ModuleList struct {
	Modules []*Module `protobuf:"bytes,1,rep,name=Modules" json:"Modules,omitempty"`
}

func (m *ModuleList) Reset()                    { *m = ModuleList{} }
func (m *ModuleList) String() string            { return proto.CompactTextString(m) }
func (*ModuleList) ProtoMessage()               {}
func (*ModuleList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ModuleList) GetModules() []*Module {
	if m != nil {
		return m.Modules
	}
	return nil
}

type RouteList struct {
	Routes []*Route `protobuf:"bytes,1,rep,name=Routes" json:"Routes,omitempty"`
}

func (m *RouteList) Reset()                    { *m = RouteList{} }
func (m *RouteList) String() string            { return proto.CompactTextString(m) }
func (*RouteList) ProtoMessage()               {}
func (*RouteList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *RouteList) GetRoutes() []*Route {
	if m != nil {
		return m.Routes
	}
	return nil
}

type Route struct {
	ID          uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Info        string `protobuf:"bytes,2,opt,name=Info" json:"Info,omitempty"`
	Created     uint32 `protobuf:"varint,3,opt,name=Created" json:"Created,omitempty"`
	LastInbound uint32 `protobuf:"varint,4,opt,name=LastInbound" json:"LastInbound,omitempty"`
	FirstNodeID uint32 `protobuf:"varint,5,opt,name=FirstNodeID" json:"FirstNodeID,omitempty"`
	LastNodeID  uint32 `protobuf:"varint,6,opt,name=LastNodeID" json:"LastNodeID,omitempty"`
}

func (m *Route) Reset()                    { *m = Route{} }
func (m *Route) String() string            { return proto.CompactTextString(m) }
func (*Route) ProtoMessage()               {}
func (*Route) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Route) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *Route) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

func (m *Route) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *Route) GetLastInbound() uint32 {
	if m != nil {
		return m.LastInbound
	}
	return 0
}

func (m *Route) GetFirstNodeID() uint32 {
	if m != nil {
		return m.FirstNodeID
	}
	return 0
}

func (m *Route) GetLastNodeID() uint32 {
	if m != nil {
		return m.LastNodeID
	}
	return 0
}

type CommandDef struct {
	ID    uint32   `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	Names []string `protobuf:"bytes,2,rep,name=Names" json:"Names,omitempty"`
}

func (m *CommandDef) Reset()                    { *m = CommandDef{} }
func (m *CommandDef) String() string            { return proto.CompactTextString(m) }
func (*CommandDef) ProtoMessage()               {}
func (*CommandDef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *CommandDef) GetID() uint32 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *CommandDef) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type CommandDefList struct {
	CommandDefs []*CommandDef `protobuf:"bytes,1,rep,name=CommandDefs" json:"CommandDefs,omitempty"`
}

func (m *CommandDefList) Reset()                    { *m = CommandDefList{} }
func (m *CommandDefList) String() string            { return proto.CompactTextString(m) }
func (*CommandDefList) ProtoMessage()               {}
func (*CommandDefList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *CommandDefList) GetCommandDefs() []*CommandDef {
	if m != nil {
		return m.CommandDefs
	}
	return nil
}

// deprecated in favor our scweb modulestatus (persistent)
type ModuleStatus struct {
	Node           uint32 `protobuf:"varint,1,opt,name=Node" json:"Node,omitempty"`
	ActiveVersion  uint32 `protobuf:"varint,2,opt,name=ActiveVersion" json:"ActiveVersion,omitempty"`
	BuildTime      uint32 `protobuf:"varint,3,opt,name=BuildTime" json:"BuildTime,omitempty"`
	Repository     uint32 `protobuf:"varint,4,opt,name=Repository" json:"Repository,omitempty"`
	Sequence       uint32 `protobuf:"varint,5,opt,name=Sequence" json:"Sequence,omitempty"`
	LastPC         uint64 `protobuf:"varint,6,opt,name=LastPC" json:"LastPC,omitempty"`
	LastResetCause uint32 `protobuf:"varint,7,opt,name=LastResetCause" json:"LastResetCause,omitempty"`
	CloudToken     string `protobuf:"bytes,8,opt,name=CloudToken" json:"CloudToken,omitempty"`
	BaseAddress    uint32 `protobuf:"varint,9,opt,name=BaseAddress" json:"BaseAddress,omitempty"`
}

func (m *ModuleStatus) Reset()                    { *m = ModuleStatus{} }
func (m *ModuleStatus) String() string            { return proto.CompactTextString(m) }
func (*ModuleStatus) ProtoMessage()               {}
func (*ModuleStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *ModuleStatus) GetNode() uint32 {
	if m != nil {
		return m.Node
	}
	return 0
}

func (m *ModuleStatus) GetActiveVersion() uint32 {
	if m != nil {
		return m.ActiveVersion
	}
	return 0
}

func (m *ModuleStatus) GetBuildTime() uint32 {
	if m != nil {
		return m.BuildTime
	}
	return 0
}

func (m *ModuleStatus) GetRepository() uint32 {
	if m != nil {
		return m.Repository
	}
	return 0
}

func (m *ModuleStatus) GetSequence() uint32 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *ModuleStatus) GetLastPC() uint64 {
	if m != nil {
		return m.LastPC
	}
	return 0
}

func (m *ModuleStatus) GetLastResetCause() uint32 {
	if m != nil {
		return m.LastResetCause
	}
	return 0
}

func (m *ModuleStatus) GetCloudToken() string {
	if m != nil {
		return m.CloudToken
	}
	return ""
}

func (m *ModuleStatus) GetBaseAddress() uint32 {
	if m != nil {
		return m.BaseAddress
	}
	return 0
}

// *****************************************
// // stuff to do with updating firmware
// ****************************************
type FirmwareLocation struct {
	Node uint32 `protobuf:"varint,1,opt,name=Node" json:"Node,omitempty"`
	// take a SPECIFIC file from server's local filesystem.
	// this is a single binary, which needs to match the linkers' base address
	// of the module. The module will reject an upgrade if it's on the same base
	// address
	// as the currently running firmware. It's better to use a distribution (which
	// contains
	// multiple linked binaries on different addresses, so the server can pick the
	// right one)
	AppFile string `protobuf:"bytes,2,opt,name=AppFile" json:"AppFile,omitempty"`
	// binary to send to module
	AppBin []byte `protobuf:"bytes,3,opt,name=AppBin,proto3" json:"AppBin,omitempty"`
}

func (m *FirmwareLocation) Reset()                    { *m = FirmwareLocation{} }
func (m *FirmwareLocation) String() string            { return proto.CompactTextString(m) }
func (*FirmwareLocation) ProtoMessage()               {}
func (*FirmwareLocation) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *FirmwareLocation) GetNode() uint32 {
	if m != nil {
		return m.Node
	}
	return 0
}

func (m *FirmwareLocation) GetAppFile() string {
	if m != nil {
		return m.AppFile
	}
	return ""
}

func (m *FirmwareLocation) GetAppBin() []byte {
	if m != nil {
		return m.AppBin
	}
	return nil
}

type SendResult struct {
	Success      bool   `protobuf:"varint,1,opt,name=Success" json:"Success,omitempty"`
	Seq          uint32 `protobuf:"varint,2,opt,name=Seq" json:"Seq,omitempty"`
	ErrorMessage string `protobuf:"bytes,3,opt,name=ErrorMessage" json:"ErrorMessage,omitempty"`
}

func (m *SendResult) Reset()                    { *m = SendResult{} }
func (m *SendResult) String() string            { return proto.CompactTextString(m) }
func (*SendResult) ProtoMessage()               {}
func (*SendResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *SendResult) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *SendResult) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *SendResult) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type UpdateStatusList struct {
	Updates []*UpdateStatus `protobuf:"bytes,1,rep,name=Updates" json:"Updates,omitempty"`
}

func (m *UpdateStatusList) Reset()                    { *m = UpdateStatusList{} }
func (m *UpdateStatusList) String() string            { return proto.CompactTextString(m) }
func (*UpdateStatusList) ProtoMessage()               {}
func (*UpdateStatusList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *UpdateStatusList) GetUpdates() []*UpdateStatus {
	if m != nil {
		return m.Updates
	}
	return nil
}

type UpdateStatus struct {
	TotalSize   uint64 `protobuf:"varint,2,opt,name=TotalSize" json:"TotalSize,omitempty"`
	TotalSent   uint64 `protobuf:"varint,3,opt,name=TotalSent" json:"TotalSent,omitempty"`
	Completed   bool   `protobuf:"varint,4,opt,name=Completed" json:"Completed,omitempty"`
	Success     bool   `protobuf:"varint,5,opt,name=Success" json:"Success,omitempty"`
	ErrorMsg    string `protobuf:"bytes,6,opt,name=ErrorMsg" json:"ErrorMsg,omitempty"`
	LastUpdated uint32 `protobuf:"varint,7,opt,name=LastUpdated" json:"LastUpdated,omitempty"`
}

func (m *UpdateStatus) Reset()                    { *m = UpdateStatus{} }
func (m *UpdateStatus) String() string            { return proto.CompactTextString(m) }
func (*UpdateStatus) ProtoMessage()               {}
func (*UpdateStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *UpdateStatus) GetTotalSize() uint64 {
	if m != nil {
		return m.TotalSize
	}
	return 0
}

func (m *UpdateStatus) GetTotalSent() uint64 {
	if m != nil {
		return m.TotalSent
	}
	return 0
}

func (m *UpdateStatus) GetCompleted() bool {
	if m != nil {
		return m.Completed
	}
	return false
}

func (m *UpdateStatus) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *UpdateStatus) GetErrorMsg() string {
	if m != nil {
		return m.ErrorMsg
	}
	return ""
}

func (m *UpdateStatus) GetLastUpdated() uint32 {
	if m != nil {
		return m.LastUpdated
	}
	return 0
}

type UpdateStatusRequest struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
}

func (m *UpdateStatusRequest) Reset()                    { *m = UpdateStatusRequest{} }
func (m *UpdateStatusRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateStatusRequest) ProtoMessage()               {}
func (*UpdateStatusRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *UpdateStatusRequest) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

type UpdateReference struct {
	ID uint64 `protobuf:"varint,1,opt,name=ID" json:"ID,omitempty"`
	// the backend
	Status *UpdateStatus `protobuf:"bytes,2,opt,name=Status" json:"Status,omitempty"`
}

func (m *UpdateReference) Reset()                    { *m = UpdateReference{} }
func (m *UpdateReference) String() string            { return proto.CompactTextString(m) }
func (*UpdateReference) ProtoMessage()               {}
func (*UpdateReference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *UpdateReference) GetID() uint64 {
	if m != nil {
		return m.ID
	}
	return 0
}

func (m *UpdateReference) GetStatus() *UpdateStatus {
	if m != nil {
		return m.Status
	}
	return nil
}

type NodeConfig struct {
	// debug mode for tcp connections for this node
	DebugTCP bool `protobuf:"varint,1,opt,name=DebugTCP" json:"DebugTCP,omitempty"`
	// debug routing for this node
	DebugRouter bool `protobuf:"varint,2,opt,name=DebugRouter" json:"DebugRouter,omitempty"`
	// debug commandhandler for this node
	DebugCommnadHandler bool `protobuf:"varint,3,opt,name=DebugCommnadHandler" json:"DebugCommnadHandler,omitempty"`
	// never use direct TCP route for this node (always ask SCRouter)
	ForceIndirect bool `protobuf:"varint,4,opt,name=ForceIndirect" json:"ForceIndirect,omitempty"`
}

func (m *NodeConfig) Reset()                    { *m = NodeConfig{} }
func (m *NodeConfig) String() string            { return proto.CompactTextString(m) }
func (*NodeConfig) ProtoMessage()               {}
func (*NodeConfig) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *NodeConfig) GetDebugTCP() bool {
	if m != nil {
		return m.DebugTCP
	}
	return false
}

func (m *NodeConfig) GetDebugRouter() bool {
	if m != nil {
		return m.DebugRouter
	}
	return false
}

func (m *NodeConfig) GetDebugCommnadHandler() bool {
	if m != nil {
		return m.DebugCommnadHandler
	}
	return false
}

func (m *NodeConfig) GetForceIndirect() bool {
	if m != nil {
		return m.ForceIndirect
	}
	return false
}

type Config struct {
	// if true, only accept a single node per tcp connection ( disable bridging).
	// Debugging
	TCPSingleRoute bool `protobuf:"varint,1,opt,name=TCPSingleRoute" json:"TCPSingleRoute,omitempty"`
	// node and their debug flags
	NodeConfigs map[uint32]*NodeConfig `protobuf:"bytes,2,rep,name=NodeConfigs" json:"NodeConfigs,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// if true, we wait until the peer says something rather then sending stuff to
	// it when it connects
	PassiveHandshakeTCP bool `protobuf:"varint,3,opt,name=PassiveHandshakeTCP" json:"PassiveHandshakeTCP,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *Config) GetTCPSingleRoute() bool {
	if m != nil {
		return m.TCPSingleRoute
	}
	return false
}

func (m *Config) GetNodeConfigs() map[uint32]*NodeConfig {
	if m != nil {
		return m.NodeConfigs
	}
	return nil
}

func (m *Config) GetPassiveHandshakeTCP() bool {
	if m != nil {
		return m.PassiveHandshakeTCP
	}
	return false
}

type IP struct {
	IPv4 string `protobuf:"bytes,1,opt,name=IPv4" json:"IPv4,omitempty"`
}

func (m *IP) Reset()                    { *m = IP{} }
func (m *IP) String() string            { return proto.CompactTextString(m) }
func (*IP) ProtoMessage()               {}
func (*IP) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *IP) GetIPv4() string {
	if m != nil {
		return m.IPv4
	}
	return ""
}

type ActiveNodesRequest struct {
	NodeIDs []uint32 `protobuf:"varint,1,rep,packed,name=NodeIDs" json:"NodeIDs,omitempty"`
}

func (m *ActiveNodesRequest) Reset()                    { *m = ActiveNodesRequest{} }
func (m *ActiveNodesRequest) String() string            { return proto.CompactTextString(m) }
func (*ActiveNodesRequest) ProtoMessage()               {}
func (*ActiveNodesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ActiveNodesRequest) GetNodeIDs() []uint32 {
	if m != nil {
		return m.NodeIDs
	}
	return nil
}

type ActiveNodesResponse struct {
	Nodes []*ActiveNodeStatus `protobuf:"bytes,1,rep,name=Nodes" json:"Nodes,omitempty"`
}

func (m *ActiveNodesResponse) Reset()                    { *m = ActiveNodesResponse{} }
func (m *ActiveNodesResponse) String() string            { return proto.CompactTextString(m) }
func (*ActiveNodesResponse) ProtoMessage()               {}
func (*ActiveNodesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *ActiveNodesResponse) GetNodes() []*ActiveNodeStatus {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type ActiveNodeStatus struct {
	Node         uint32 `protobuf:"varint,1,opt,name=Node" json:"Node,omitempty"`
	LastReceived uint32 `protobuf:"varint,2,opt,name=LastReceived" json:"LastReceived,omitempty"`
	LastSent     uint32 `protobuf:"varint,3,opt,name=LastSent" json:"LastSent,omitempty"`
	Sequence     uint64 `protobuf:"varint,4,opt,name=Sequence" json:"Sequence,omitempty"`
}

func (m *ActiveNodeStatus) Reset()                    { *m = ActiveNodeStatus{} }
func (m *ActiveNodeStatus) String() string            { return proto.CompactTextString(m) }
func (*ActiveNodeStatus) ProtoMessage()               {}
func (*ActiveNodeStatus) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *ActiveNodeStatus) GetNode() uint32 {
	if m != nil {
		return m.Node
	}
	return 0
}

func (m *ActiveNodeStatus) GetLastReceived() uint32 {
	if m != nil {
		return m.LastReceived
	}
	return 0
}

func (m *ActiveNodeStatus) GetLastSent() uint32 {
	if m != nil {
		return m.LastSent
	}
	return 0
}

func (m *ActiveNodeStatus) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

type TCPConnectionList struct {
	Connections []*TCPConnection `protobuf:"bytes,1,rep,name=Connections" json:"Connections,omitempty"`
}

func (m *TCPConnectionList) Reset()                    { *m = TCPConnectionList{} }
func (m *TCPConnectionList) String() string            { return proto.CompactTextString(m) }
func (*TCPConnectionList) ProtoMessage()               {}
func (*TCPConnectionList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *TCPConnectionList) GetConnections() []*TCPConnection {
	if m != nil {
		return m.Connections
	}
	return nil
}

// debug information. see TCPConn in sourcecode
type TCPConnection struct {
	Sequence            uint64 `protobuf:"varint,1,opt,name=Sequence" json:"Sequence,omitempty"`
	Peer                string `protobuf:"bytes,2,opt,name=Peer" json:"Peer,omitempty"`
	Broken              bool   `protobuf:"varint,3,opt,name=Broken" json:"Broken,omitempty"`
	Failures            uint32 `protobuf:"varint,4,opt,name=Failures" json:"Failures,omitempty"`
	NodeID              uint32 `protobuf:"varint,5,opt,name=NodeID" json:"NodeID,omitempty"`
	LastReceived        uint32 `protobuf:"varint,6,opt,name=LastReceived" json:"LastReceived,omitempty"`
	Created             uint32 `protobuf:"varint,7,opt,name=Created" json:"Created,omitempty"`
	Routing             bool   `protobuf:"varint,8,opt,name=Routing" json:"Routing,omitempty"`
	ParserCurrentBuffer []byte `protobuf:"bytes,9,opt,name=ParserCurrentBuffer,proto3" json:"ParserCurrentBuffer,omitempty"`
	ParserIsEscaped     bool   `protobuf:"varint,10,opt,name=ParserIsEscaped" json:"ParserIsEscaped,omitempty"`
	ParserIsStarted     bool   `protobuf:"varint,11,opt,name=ParserIsStarted" json:"ParserIsStarted,omitempty"`
}

func (m *TCPConnection) Reset()                    { *m = TCPConnection{} }
func (m *TCPConnection) String() string            { return proto.CompactTextString(m) }
func (*TCPConnection) ProtoMessage()               {}
func (*TCPConnection) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *TCPConnection) GetSequence() uint64 {
	if m != nil {
		return m.Sequence
	}
	return 0
}

func (m *TCPConnection) GetPeer() string {
	if m != nil {
		return m.Peer
	}
	return ""
}

func (m *TCPConnection) GetBroken() bool {
	if m != nil {
		return m.Broken
	}
	return false
}

func (m *TCPConnection) GetFailures() uint32 {
	if m != nil {
		return m.Failures
	}
	return 0
}

func (m *TCPConnection) GetNodeID() uint32 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *TCPConnection) GetLastReceived() uint32 {
	if m != nil {
		return m.LastReceived
	}
	return 0
}

func (m *TCPConnection) GetCreated() uint32 {
	if m != nil {
		return m.Created
	}
	return 0
}

func (m *TCPConnection) GetRouting() bool {
	if m != nil {
		return m.Routing
	}
	return false
}

func (m *TCPConnection) GetParserCurrentBuffer() []byte {
	if m != nil {
		return m.ParserCurrentBuffer
	}
	return nil
}

func (m *TCPConnection) GetParserIsEscaped() bool {
	if m != nil {
		return m.ParserIsEscaped
	}
	return false
}

func (m *TCPConnection) GetParserIsStarted() bool {
	if m != nil {
		return m.ParserIsStarted
	}
	return false
}

type SendWithResponseRequest struct {
	Com            *singingcat.Command `protobuf:"bytes,1,opt,name=Com" json:"Com,omitempty"`
	MaxWaitMS      uint32              `protobuf:"varint,2,opt,name=MaxWaitMS" json:"MaxWaitMS,omitempty"`
	MaxResponses   uint32              `protobuf:"varint,3,opt,name=MaxResponses" json:"MaxResponses,omitempty"`
	MaxWaitFirstMS uint32              `protobuf:"varint,4,opt,name=MaxWaitFirstMS" json:"MaxWaitFirstMS,omitempty"`
}

func (m *SendWithResponseRequest) Reset()                    { *m = SendWithResponseRequest{} }
func (m *SendWithResponseRequest) String() string            { return proto.CompactTextString(m) }
func (*SendWithResponseRequest) ProtoMessage()               {}
func (*SendWithResponseRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *SendWithResponseRequest) GetCom() *singingcat.Command {
	if m != nil {
		return m.Com
	}
	return nil
}

func (m *SendWithResponseRequest) GetMaxWaitMS() uint32 {
	if m != nil {
		return m.MaxWaitMS
	}
	return 0
}

func (m *SendWithResponseRequest) GetMaxResponses() uint32 {
	if m != nil {
		return m.MaxResponses
	}
	return 0
}

func (m *SendWithResponseRequest) GetMaxWaitFirstMS() uint32 {
	if m != nil {
		return m.MaxWaitFirstMS
	}
	return 0
}

type Response struct {
	Milliseconds uint32              `protobuf:"varint,1,opt,name=Milliseconds" json:"Milliseconds,omitempty"`
	Response     *singingcat.Command `protobuf:"bytes,2,opt,name=Response" json:"Response,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *Response) GetMilliseconds() uint32 {
	if m != nil {
		return m.Milliseconds
	}
	return 0
}

func (m *Response) GetResponse() *singingcat.Command {
	if m != nil {
		return m.Response
	}
	return nil
}

type SendWithResponseResult struct {
	Sent      *singingcat.Command `protobuf:"bytes,1,opt,name=Sent" json:"Sent,omitempty"`
	Seq       uint32              `protobuf:"varint,2,opt,name=Seq" json:"Seq,omitempty"`
	Responses []*Response         `protobuf:"bytes,3,rep,name=Responses" json:"Responses,omitempty"`
}

func (m *SendWithResponseResult) Reset()                    { *m = SendWithResponseResult{} }
func (m *SendWithResponseResult) String() string            { return proto.CompactTextString(m) }
func (*SendWithResponseResult) ProtoMessage()               {}
func (*SendWithResponseResult) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *SendWithResponseResult) GetSent() *singingcat.Command {
	if m != nil {
		return m.Sent
	}
	return nil
}

func (m *SendWithResponseResult) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func (m *SendWithResponseResult) GetResponses() []*Response {
	if m != nil {
		return m.Responses
	}
	return nil
}

type DirectRouteRequest struct {
	NodeIDs []uint32 `protobuf:"varint,1,rep,packed,name=NodeIDs" json:"NodeIDs,omitempty"`
}

func (m *DirectRouteRequest) Reset()                    { *m = DirectRouteRequest{} }
func (m *DirectRouteRequest) String() string            { return proto.CompactTextString(m) }
func (*DirectRouteRequest) ProtoMessage()               {}
func (*DirectRouteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *DirectRouteRequest) GetNodeIDs() []uint32 {
	if m != nil {
		return m.NodeIDs
	}
	return nil
}

type DirectNodeResponse struct {
	NodeID         uint32 `protobuf:"varint,1,opt,name=NodeID" json:"NodeID,omitempty"`
	DirectRoutable bool   `protobuf:"varint,2,opt,name=DirectRoutable" json:"DirectRoutable,omitempty"`
}

func (m *DirectNodeResponse) Reset()                    { *m = DirectNodeResponse{} }
func (m *DirectNodeResponse) String() string            { return proto.CompactTextString(m) }
func (*DirectNodeResponse) ProtoMessage()               {}
func (*DirectNodeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *DirectNodeResponse) GetNodeID() uint32 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *DirectNodeResponse) GetDirectRoutable() bool {
	if m != nil {
		return m.DirectRoutable
	}
	return false
}

type DirectRouteResponse struct {
	Nodes []*DirectNodeResponse `protobuf:"bytes,1,rep,name=Nodes" json:"Nodes,omitempty"`
}

func (m *DirectRouteResponse) Reset()                    { *m = DirectRouteResponse{} }
func (m *DirectRouteResponse) String() string            { return proto.CompactTextString(m) }
func (*DirectRouteResponse) ProtoMessage()               {}
func (*DirectRouteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *DirectRouteResponse) GetNodes() []*DirectNodeResponse {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type ListenRequest struct {
}

func (m *ListenRequest) Reset()                    { *m = ListenRequest{} }
func (m *ListenRequest) String() string            { return proto.CompactTextString(m) }
func (*ListenRequest) ProtoMessage()               {}
func (*ListenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

type ListenStream struct {
	Inbound   bool                `protobuf:"varint,1,opt,name=Inbound" json:"Inbound,omitempty"`
	Command   *singingcat.Command `protobuf:"bytes,2,opt,name=Command" json:"Command,omitempty"`
	Timestamp uint32              `protobuf:"varint,3,opt,name=Timestamp" json:"Timestamp,omitempty"`
}

func (m *ListenStream) Reset()                    { *m = ListenStream{} }
func (m *ListenStream) String() string            { return proto.CompactTextString(m) }
func (*ListenStream) ProtoMessage()               {}
func (*ListenStream) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *ListenStream) GetInbound() bool {
	if m != nil {
		return m.Inbound
	}
	return false
}

func (m *ListenStream) GetCommand() *singingcat.Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *ListenStream) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

type SequenceNumber struct {
	Seq uint32 `protobuf:"varint,1,opt,name=Seq" json:"Seq,omitempty"`
}

func (m *SequenceNumber) Reset()                    { *m = SequenceNumber{} }
func (m *SequenceNumber) String() string            { return proto.CompactTextString(m) }
func (*SequenceNumber) ProtoMessage()               {}
func (*SequenceNumber) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *SequenceNumber) GetSeq() uint32 {
	if m != nil {
		return m.Seq
	}
	return 0
}

func init() {
	proto.RegisterType((*ModuleRef)(nil), "scserver.ModuleRef")
	proto.RegisterType((*Module)(nil), "scserver.Module")
	proto.RegisterType((*ModuleList)(nil), "scserver.ModuleList")
	proto.RegisterType((*RouteList)(nil), "scserver.RouteList")
	proto.RegisterType((*Route)(nil), "scserver.Route")
	proto.RegisterType((*CommandDef)(nil), "scserver.CommandDef")
	proto.RegisterType((*CommandDefList)(nil), "scserver.CommandDefList")
	proto.RegisterType((*ModuleStatus)(nil), "scserver.ModuleStatus")
	proto.RegisterType((*FirmwareLocation)(nil), "scserver.FirmwareLocation")
	proto.RegisterType((*SendResult)(nil), "scserver.SendResult")
	proto.RegisterType((*UpdateStatusList)(nil), "scserver.UpdateStatusList")
	proto.RegisterType((*UpdateStatus)(nil), "scserver.UpdateStatus")
	proto.RegisterType((*UpdateStatusRequest)(nil), "scserver.UpdateStatusRequest")
	proto.RegisterType((*UpdateReference)(nil), "scserver.UpdateReference")
	proto.RegisterType((*NodeConfig)(nil), "scserver.NodeConfig")
	proto.RegisterType((*Config)(nil), "scserver.Config")
	proto.RegisterType((*IP)(nil), "scserver.IP")
	proto.RegisterType((*ActiveNodesRequest)(nil), "scserver.ActiveNodesRequest")
	proto.RegisterType((*ActiveNodesResponse)(nil), "scserver.ActiveNodesResponse")
	proto.RegisterType((*ActiveNodeStatus)(nil), "scserver.ActiveNodeStatus")
	proto.RegisterType((*TCPConnectionList)(nil), "scserver.TCPConnectionList")
	proto.RegisterType((*TCPConnection)(nil), "scserver.TCPConnection")
	proto.RegisterType((*SendWithResponseRequest)(nil), "scserver.SendWithResponseRequest")
	proto.RegisterType((*Response)(nil), "scserver.Response")
	proto.RegisterType((*SendWithResponseResult)(nil), "scserver.SendWithResponseResult")
	proto.RegisterType((*DirectRouteRequest)(nil), "scserver.DirectRouteRequest")
	proto.RegisterType((*DirectNodeResponse)(nil), "scserver.DirectNodeResponse")
	proto.RegisterType((*DirectRouteResponse)(nil), "scserver.DirectRouteResponse")
	proto.RegisterType((*ListenRequest)(nil), "scserver.ListenRequest")
	proto.RegisterType((*ListenStream)(nil), "scserver.ListenStream")
	proto.RegisterType((*SequenceNumber)(nil), "scserver.SequenceNumber")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for SCServer service

type SCServerClient interface {
	// DEPRECATED list all modules which are currently online
	ListKnownModules(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*ModuleList, error)
	// DEPRECATED see scrouter
	ListKnownRoutes(ctx context.Context, in *Module, opts ...grpc.CallOption) (*RouteList, error)
	// DEPRECATED send and block until reply received
	Send(ctx context.Context, in *singingcat.Command, opts ...grpc.CallOption) (*singingcat.Status, error)
	// send and block until reply received
	SendSync(ctx context.Context, in *singingcat.Command, opts ...grpc.CallOption) (*SendResult, error)
	// send (do not block for replies)
	SendAsync(ctx context.Context, in *singingcat.Command, opts ...grpc.CallOption) (*SendResult, error)
	ListKnownCommands(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*CommandDefList, error)
	StartEnquiry(ctx context.Context, in *ModuleRef, opts ...grpc.CallOption) (*singingcat.Status, error)
	GetModuleStatus(ctx context.Context, in *ModuleRef, opts ...grpc.CallOption) (*ModuleStatus, error)
	// DEPRECATED update a singingcat module with a new application firmware
	UpdateAppFirmware(ctx context.Context, in *FirmwareLocation, opts ...grpc.CallOption) (*UpdateReference, error)
	// DEPRECATED get the status of an update
	GetUpdateStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*UpdateStatus, error)
	// DEPRECATED get all current updates
	GetUpdates(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*UpdateStatusList, error)
	// DEPRECATED add an IP to probe for a singingcat on
	AddStaticIP(ctx context.Context, in *IP, opts ...grpc.CallOption) (*singingcat.Status, error)
	// DEPRECATED remove an IP to probe for a singingcat on
	RemoveStaticIP(ctx context.Context, in *IP, opts ...grpc.CallOption) (*singingcat.Status, error)
	// get current config
	GetConfig(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*Config, error)
	// set config, returning old config
	SetConfig(ctx context.Context, in *Config, opts ...grpc.CallOption) (*Config, error)
	// given a list of nodes, get most recent traffic received from/to
	GetActiveStatus(ctx context.Context, in *ActiveNodesRequest, opts ...grpc.CallOption) (*ActiveNodesResponse, error)
	// debug method to get tcp connections of this instance
	GetTCPConnections(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*TCPConnectionList, error)
	// this is like Send() - it is synchronous and waits for results to come in and returns those
	SendWithResponse(ctx context.Context, in *SendWithResponseRequest, opts ...grpc.CallOption) (*SendWithResponseResult, error)
	// Check for direct routes to nodes
	DirectRouteAvailable(ctx context.Context, in *DirectRouteRequest, opts ...grpc.CallOption) (*DirectRouteResponse, error)
	// Listen to inbound/outbound packets
	Listen(ctx context.Context, in *ListenRequest, opts ...grpc.CallOption) (SCServer_ListenClient, error)
	// reserve a sequence number
	ReserveSeq(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*SequenceNumber, error)
	// Disconnect a module (tcp connection)
	Disconnect(ctx context.Context, in *ModuleRef, opts ...grpc.CallOption) (*common.Void, error)
}

type sCServerClient struct {
	cc *grpc.ClientConn
}

func NewSCServerClient(cc *grpc.ClientConn) SCServerClient {
	return &sCServerClient{cc}
}

func (c *sCServerClient) ListKnownModules(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*ModuleList, error) {
	out := new(ModuleList)
	err := grpc.Invoke(ctx, "/scserver.SCServer/ListKnownModules", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) ListKnownRoutes(ctx context.Context, in *Module, opts ...grpc.CallOption) (*RouteList, error) {
	out := new(RouteList)
	err := grpc.Invoke(ctx, "/scserver.SCServer/ListKnownRoutes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) Send(ctx context.Context, in *singingcat.Command, opts ...grpc.CallOption) (*singingcat.Status, error) {
	out := new(singingcat.Status)
	err := grpc.Invoke(ctx, "/scserver.SCServer/Send", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) SendSync(ctx context.Context, in *singingcat.Command, opts ...grpc.CallOption) (*SendResult, error) {
	out := new(SendResult)
	err := grpc.Invoke(ctx, "/scserver.SCServer/SendSync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) SendAsync(ctx context.Context, in *singingcat.Command, opts ...grpc.CallOption) (*SendResult, error) {
	out := new(SendResult)
	err := grpc.Invoke(ctx, "/scserver.SCServer/SendAsync", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) ListKnownCommands(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*CommandDefList, error) {
	out := new(CommandDefList)
	err := grpc.Invoke(ctx, "/scserver.SCServer/ListKnownCommands", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) StartEnquiry(ctx context.Context, in *ModuleRef, opts ...grpc.CallOption) (*singingcat.Status, error) {
	out := new(singingcat.Status)
	err := grpc.Invoke(ctx, "/scserver.SCServer/StartEnquiry", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) GetModuleStatus(ctx context.Context, in *ModuleRef, opts ...grpc.CallOption) (*ModuleStatus, error) {
	out := new(ModuleStatus)
	err := grpc.Invoke(ctx, "/scserver.SCServer/GetModuleStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) UpdateAppFirmware(ctx context.Context, in *FirmwareLocation, opts ...grpc.CallOption) (*UpdateReference, error) {
	out := new(UpdateReference)
	err := grpc.Invoke(ctx, "/scserver.SCServer/UpdateAppFirmware", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) GetUpdateStatus(ctx context.Context, in *UpdateStatusRequest, opts ...grpc.CallOption) (*UpdateStatus, error) {
	out := new(UpdateStatus)
	err := grpc.Invoke(ctx, "/scserver.SCServer/GetUpdateStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) GetUpdates(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*UpdateStatusList, error) {
	out := new(UpdateStatusList)
	err := grpc.Invoke(ctx, "/scserver.SCServer/GetUpdates", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) AddStaticIP(ctx context.Context, in *IP, opts ...grpc.CallOption) (*singingcat.Status, error) {
	out := new(singingcat.Status)
	err := grpc.Invoke(ctx, "/scserver.SCServer/AddStaticIP", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) RemoveStaticIP(ctx context.Context, in *IP, opts ...grpc.CallOption) (*singingcat.Status, error) {
	out := new(singingcat.Status)
	err := grpc.Invoke(ctx, "/scserver.SCServer/RemoveStaticIP", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) GetConfig(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := grpc.Invoke(ctx, "/scserver.SCServer/GetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) SetConfig(ctx context.Context, in *Config, opts ...grpc.CallOption) (*Config, error) {
	out := new(Config)
	err := grpc.Invoke(ctx, "/scserver.SCServer/SetConfig", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) GetActiveStatus(ctx context.Context, in *ActiveNodesRequest, opts ...grpc.CallOption) (*ActiveNodesResponse, error) {
	out := new(ActiveNodesResponse)
	err := grpc.Invoke(ctx, "/scserver.SCServer/GetActiveStatus", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) GetTCPConnections(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*TCPConnectionList, error) {
	out := new(TCPConnectionList)
	err := grpc.Invoke(ctx, "/scserver.SCServer/GetTCPConnections", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) SendWithResponse(ctx context.Context, in *SendWithResponseRequest, opts ...grpc.CallOption) (*SendWithResponseResult, error) {
	out := new(SendWithResponseResult)
	err := grpc.Invoke(ctx, "/scserver.SCServer/SendWithResponse", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) DirectRouteAvailable(ctx context.Context, in *DirectRouteRequest, opts ...grpc.CallOption) (*DirectRouteResponse, error) {
	out := new(DirectRouteResponse)
	err := grpc.Invoke(ctx, "/scserver.SCServer/DirectRouteAvailable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) Listen(ctx context.Context, in *ListenRequest, opts ...grpc.CallOption) (SCServer_ListenClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_SCServer_serviceDesc.Streams[0], c.cc, "/scserver.SCServer/Listen", opts...)
	if err != nil {
		return nil, err
	}
	x := &sCServerListenClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type SCServer_ListenClient interface {
	Recv() (*ListenStream, error)
	grpc.ClientStream
}

type sCServerListenClient struct {
	grpc.ClientStream
}

func (x *sCServerListenClient) Recv() (*ListenStream, error) {
	m := new(ListenStream)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *sCServerClient) ReserveSeq(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*SequenceNumber, error) {
	out := new(SequenceNumber)
	err := grpc.Invoke(ctx, "/scserver.SCServer/ReserveSeq", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *sCServerClient) Disconnect(ctx context.Context, in *ModuleRef, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/scserver.SCServer/Disconnect", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SCServer service

type SCServerServer interface {
	// DEPRECATED list all modules which are currently online
	ListKnownModules(context.Context, *common.Void) (*ModuleList, error)
	// DEPRECATED see scrouter
	ListKnownRoutes(context.Context, *Module) (*RouteList, error)
	// DEPRECATED send and block until reply received
	Send(context.Context, *singingcat.Command) (*singingcat.Status, error)
	// send and block until reply received
	SendSync(context.Context, *singingcat.Command) (*SendResult, error)
	// send (do not block for replies)
	SendAsync(context.Context, *singingcat.Command) (*SendResult, error)
	ListKnownCommands(context.Context, *common.Void) (*CommandDefList, error)
	StartEnquiry(context.Context, *ModuleRef) (*singingcat.Status, error)
	GetModuleStatus(context.Context, *ModuleRef) (*ModuleStatus, error)
	// DEPRECATED update a singingcat module with a new application firmware
	UpdateAppFirmware(context.Context, *FirmwareLocation) (*UpdateReference, error)
	// DEPRECATED get the status of an update
	GetUpdateStatus(context.Context, *UpdateStatusRequest) (*UpdateStatus, error)
	// DEPRECATED get all current updates
	GetUpdates(context.Context, *common.Void) (*UpdateStatusList, error)
	// DEPRECATED add an IP to probe for a singingcat on
	AddStaticIP(context.Context, *IP) (*singingcat.Status, error)
	// DEPRECATED remove an IP to probe for a singingcat on
	RemoveStaticIP(context.Context, *IP) (*singingcat.Status, error)
	// get current config
	GetConfig(context.Context, *common.Void) (*Config, error)
	// set config, returning old config
	SetConfig(context.Context, *Config) (*Config, error)
	// given a list of nodes, get most recent traffic received from/to
	GetActiveStatus(context.Context, *ActiveNodesRequest) (*ActiveNodesResponse, error)
	// debug method to get tcp connections of this instance
	GetTCPConnections(context.Context, *common.Void) (*TCPConnectionList, error)
	// this is like Send() - it is synchronous and waits for results to come in and returns those
	SendWithResponse(context.Context, *SendWithResponseRequest) (*SendWithResponseResult, error)
	// Check for direct routes to nodes
	DirectRouteAvailable(context.Context, *DirectRouteRequest) (*DirectRouteResponse, error)
	// Listen to inbound/outbound packets
	Listen(*ListenRequest, SCServer_ListenServer) error
	// reserve a sequence number
	ReserveSeq(context.Context, *common.Void) (*SequenceNumber, error)
	// Disconnect a module (tcp connection)
	Disconnect(context.Context, *ModuleRef) (*common.Void, error)
}

func RegisterSCServerServer(s *grpc.Server, srv SCServerServer) {
	s.RegisterService(&_SCServer_serviceDesc, srv)
}

func _SCServer_ListKnownModules_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).ListKnownModules(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/ListKnownModules",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).ListKnownModules(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_ListKnownRoutes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Module)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).ListKnownRoutes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/ListKnownRoutes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).ListKnownRoutes(ctx, req.(*Module))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_Send_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).Send(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/Send",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).Send(ctx, req.(*singingcat.Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_SendSync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).SendSync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/SendSync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).SendSync(ctx, req.(*singingcat.Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_SendAsync_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(singingcat.Command)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).SendAsync(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/SendAsync",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).SendAsync(ctx, req.(*singingcat.Command))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_ListKnownCommands_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).ListKnownCommands(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/ListKnownCommands",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).ListKnownCommands(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_StartEnquiry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).StartEnquiry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/StartEnquiry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).StartEnquiry(ctx, req.(*ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_GetModuleStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).GetModuleStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/GetModuleStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).GetModuleStatus(ctx, req.(*ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_UpdateAppFirmware_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FirmwareLocation)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).UpdateAppFirmware(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/UpdateAppFirmware",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).UpdateAppFirmware(ctx, req.(*FirmwareLocation))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_GetUpdateStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UpdateStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).GetUpdateStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/GetUpdateStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).GetUpdateStatus(ctx, req.(*UpdateStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_GetUpdates_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).GetUpdates(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/GetUpdates",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).GetUpdates(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_AddStaticIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IP)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).AddStaticIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/AddStaticIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).AddStaticIP(ctx, req.(*IP))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_RemoveStaticIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(IP)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).RemoveStaticIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/RemoveStaticIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).RemoveStaticIP(ctx, req.(*IP))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_GetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).GetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/GetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).GetConfig(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_SetConfig_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Config)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).SetConfig(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/SetConfig",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).SetConfig(ctx, req.(*Config))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_GetActiveStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ActiveNodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).GetActiveStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/GetActiveStatus",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).GetActiveStatus(ctx, req.(*ActiveNodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_GetTCPConnections_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).GetTCPConnections(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/GetTCPConnections",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).GetTCPConnections(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_SendWithResponse_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendWithResponseRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).SendWithResponse(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/SendWithResponse",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).SendWithResponse(ctx, req.(*SendWithResponseRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_DirectRouteAvailable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DirectRouteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).DirectRouteAvailable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/DirectRouteAvailable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).DirectRouteAvailable(ctx, req.(*DirectRouteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_Listen_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ListenRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(SCServerServer).Listen(m, &sCServerListenServer{stream})
}

type SCServer_ListenServer interface {
	Send(*ListenStream) error
	grpc.ServerStream
}

type sCServerListenServer struct {
	grpc.ServerStream
}

func (x *sCServerListenServer) Send(m *ListenStream) error {
	return x.ServerStream.SendMsg(m)
}

func _SCServer_ReserveSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).ReserveSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/ReserveSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).ReserveSeq(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _SCServer_Disconnect_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ModuleRef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SCServerServer).Disconnect(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/scserver.SCServer/Disconnect",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SCServerServer).Disconnect(ctx, req.(*ModuleRef))
	}
	return interceptor(ctx, in, info, handler)
}

var _SCServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "scserver.SCServer",
	HandlerType: (*SCServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "ListKnownModules",
			Handler:    _SCServer_ListKnownModules_Handler,
		},
		{
			MethodName: "ListKnownRoutes",
			Handler:    _SCServer_ListKnownRoutes_Handler,
		},
		{
			MethodName: "Send",
			Handler:    _SCServer_Send_Handler,
		},
		{
			MethodName: "SendSync",
			Handler:    _SCServer_SendSync_Handler,
		},
		{
			MethodName: "SendAsync",
			Handler:    _SCServer_SendAsync_Handler,
		},
		{
			MethodName: "ListKnownCommands",
			Handler:    _SCServer_ListKnownCommands_Handler,
		},
		{
			MethodName: "StartEnquiry",
			Handler:    _SCServer_StartEnquiry_Handler,
		},
		{
			MethodName: "GetModuleStatus",
			Handler:    _SCServer_GetModuleStatus_Handler,
		},
		{
			MethodName: "UpdateAppFirmware",
			Handler:    _SCServer_UpdateAppFirmware_Handler,
		},
		{
			MethodName: "GetUpdateStatus",
			Handler:    _SCServer_GetUpdateStatus_Handler,
		},
		{
			MethodName: "GetUpdates",
			Handler:    _SCServer_GetUpdates_Handler,
		},
		{
			MethodName: "AddStaticIP",
			Handler:    _SCServer_AddStaticIP_Handler,
		},
		{
			MethodName: "RemoveStaticIP",
			Handler:    _SCServer_RemoveStaticIP_Handler,
		},
		{
			MethodName: "GetConfig",
			Handler:    _SCServer_GetConfig_Handler,
		},
		{
			MethodName: "SetConfig",
			Handler:    _SCServer_SetConfig_Handler,
		},
		{
			MethodName: "GetActiveStatus",
			Handler:    _SCServer_GetActiveStatus_Handler,
		},
		{
			MethodName: "GetTCPConnections",
			Handler:    _SCServer_GetTCPConnections_Handler,
		},
		{
			MethodName: "SendWithResponse",
			Handler:    _SCServer_SendWithResponse_Handler,
		},
		{
			MethodName: "DirectRouteAvailable",
			Handler:    _SCServer_DirectRouteAvailable_Handler,
		},
		{
			MethodName: "ReserveSeq",
			Handler:    _SCServer_ReserveSeq_Handler,
		},
		{
			MethodName: "Disconnect",
			Handler:    _SCServer_Disconnect_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Listen",
			Handler:       _SCServer_Listen_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "golang.singingcat.net/apis/scserver/scserver.proto",
}

func init() { proto.RegisterFile("golang.singingcat.net/apis/scserver/scserver.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1773 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x94, 0x58, 0x5f, 0x6f, 0x23, 0x49,
	0x11, 0x97, 0xf3, 0xc7, 0x7f, 0x2a, 0x4e, 0xe2, 0xed, 0xac, 0xf6, 0x06, 0x73, 0x07, 0xb9, 0x81,
	0xdd, 0x8b, 0x0e, 0xe1, 0x44, 0x61, 0x09, 0x0b, 0x27, 0x9d, 0x48, 0x9c, 0xcd, 0xae, 0x61, 0x13,
	0x99, 0x76, 0xb8, 0xe5, 0x01, 0x09, 0x4d, 0x66, 0xca, 0xbe, 0xd6, 0xda, 0x3d, 0xde, 0xe9, 0x1e,
	0xef, 0x85, 0x47, 0x24, 0xbe, 0x08, 0xe2, 0x05, 0x3e, 0x05, 0x2f, 0x7c, 0x18, 0x3e, 0x04, 0x12,
	0xea, 0x3f, 0x33, 0xd3, 0x33, 0x99, 0x04, 0xed, 0x53, 0xa6, 0xaa, 0xab, 0xda, 0x55, 0xbf, 0xae,
	0xfa, 0x75, 0x75, 0xe0, 0x78, 0x16, 0xcf, 0x03, 0x3e, 0x1b, 0x08, 0xc6, 0x67, 0x8c, 0xcf, 0xc2,
	0x40, 0x0e, 0x38, 0xca, 0xc3, 0x60, 0xc9, 0xc4, 0xa1, 0x08, 0x05, 0x26, 0x2b, 0x4c, 0xf2, 0x8f,
	0xc1, 0x32, 0x89, 0x65, 0x4c, 0xda, 0x99, 0xdc, 0x3f, 0x79, 0xc8, 0x3b, 0xd7, 0x39, 0x9f, 0x66,
	0x87, 0xfe, 0xc0, 0xfa, 0x85, 0x31, 0x4f, 0x82, 0xe8, 0x43, 0x1c, 0x47, 0x85, 0x5f, 0x18, 0x2f,
	0x16, 0x31, 0xb7, 0x7f, 0x8c, 0xbd, 0xff, 0x43, 0xe8, 0x5c, 0xc6, 0x51, 0x3a, 0x47, 0x8a, 0x53,
	0x42, 0x60, 0xe3, 0x2a, 0x8e, 0xd0, 0x6b, 0xec, 0x37, 0x0e, 0xb6, 0xa9, 0xfe, 0xf6, 0x7f, 0x0d,
	0x4d, 0x63, 0x50, 0xb7, 0x4a, 0x7c, 0xe8, 0x5e, 0x24, 0x0c, 0x79, 0x34, 0xbf, 0xbd, 0x0a, 0x16,
	0xe8, 0xad, 0xed, 0x37, 0x0e, 0x3a, 0xb4, 0xa4, 0xf3, 0x5f, 0x00, 0x98, 0x1d, 0xde, 0x30, 0x21,
	0xc9, 0x97, 0xd0, 0x32, 0x92, 0xf0, 0x1a, 0xfb, 0xeb, 0x07, 0x5b, 0xc7, 0xbd, 0x41, 0x0e, 0x82,
	0x8d, 0x24, 0x33, 0xf0, 0x9f, 0x43, 0x87, 0xc6, 0xa9, 0x34, 0x8e, 0x5f, 0x40, 0x53, 0x0b, 0x99,
	0xdf, 0x6e, 0xe1, 0xa7, 0xf5, 0xd4, 0x2e, 0xfb, 0xff, 0x68, 0xc0, 0xa6, 0xfe, 0x24, 0x3b, 0xb0,
	0x36, 0x3a, 0xd7, 0xf1, 0x6e, 0xd0, 0xb5, 0xd1, 0xb9, 0xca, 0x60, 0xc4, 0xa7, 0xb1, 0x8d, 0x52,
	0x7f, 0x13, 0x0f, 0x5a, 0xc3, 0x04, 0x03, 0x89, 0x91, 0xb7, 0xae, 0x13, 0xcb, 0x44, 0xb2, 0x0f,
	0x5b, 0x6f, 0x02, 0x21, 0x47, 0xfc, 0x26, 0x4e, 0x79, 0xe4, 0x6d, 0xe8, 0x55, 0x57, 0xa5, 0x2c,
	0x2e, 0x58, 0x22, 0xa4, 0x82, 0x62, 0x74, 0xee, 0x6d, 0x1a, 0x0b, 0x47, 0x45, 0x7e, 0x00, 0xa0,
	0x1c, 0xac, 0x41, 0x53, 0x1b, 0x38, 0x1a, 0xff, 0x18, 0x60, 0x18, 0x2f, 0x16, 0x01, 0x8f, 0xce,
	0x71, 0xea, 0xc4, 0xbb, 0xad, 0xe3, 0x7d, 0x0c, 0x9b, 0x0a, 0x41, 0xe1, 0xad, 0xed, 0xaf, 0x1f,
	0x74, 0xa8, 0x11, 0xfc, 0xd7, 0xb0, 0x53, 0xf8, 0x68, 0x68, 0x4e, 0x60, 0xab, 0xd0, 0x64, 0xf8,
	0x3c, 0x2e, 0xf0, 0x29, 0x16, 0xa9, 0x6b, 0xe8, 0xff, 0x7d, 0x0d, 0xba, 0x06, 0xeb, 0x89, 0x0c,
	0x64, 0x2a, 0x6a, 0x8f, 0xf8, 0xc7, 0xb0, 0x7d, 0x1a, 0x4a, 0xb6, 0xc2, 0x6f, 0x30, 0x11, 0x2c,
	0xe6, 0x1a, 0xbd, 0x6d, 0x5a, 0x56, 0x92, 0x4f, 0xa1, 0x73, 0x96, 0xb2, 0x79, 0x74, 0xcd, 0x16,
	0x68, 0x81, 0x2c, 0x14, 0x0a, 0x06, 0x8a, 0xcb, 0x58, 0x30, 0x19, 0x27, 0xb7, 0x16, 0x49, 0x47,
	0x43, 0xfa, 0xd0, 0x9e, 0xe0, 0xfb, 0x14, 0x79, 0x88, 0x16, 0xc5, 0x5c, 0x26, 0x4f, 0xa0, 0xa9,
	0x00, 0x1b, 0x0f, 0x35, 0x7c, 0x1b, 0xd4, 0x4a, 0xe4, 0x19, 0xec, 0xa8, 0x2f, 0x8a, 0x02, 0xe5,
	0x30, 0x48, 0x05, 0x7a, 0x2d, 0xed, 0x59, 0xd1, 0xaa, 0xdf, 0x1e, 0xce, 0xe3, 0x34, 0xba, 0x8e,
	0xdf, 0x21, 0xf7, 0xda, 0xfa, 0xe8, 0x1d, 0x8d, 0x3a, 0xc4, 0xb3, 0x40, 0xe0, 0x69, 0x14, 0x25,
	0x28, 0x84, 0xd7, 0x31, 0x87, 0xe8, 0xa8, 0xfc, 0x3f, 0x40, 0xef, 0x82, 0x25, 0x8b, 0x0f, 0x41,
	0x82, 0x6f, 0xe2, 0x30, 0x90, 0x2a, 0xdf, 0x3a, 0xa4, 0x3c, 0x68, 0x9d, 0x2e, 0x97, 0x17, 0x6c,
	0x9e, 0xf5, 0x41, 0x26, 0xaa, 0x1c, 0x4e, 0x97, 0xcb, 0x33, 0xc6, 0x35, 0x34, 0x5d, 0x6a, 0x25,
	0xff, 0x8f, 0x00, 0x13, 0xe4, 0x11, 0x45, 0x91, 0xce, 0xa5, 0xf2, 0x9f, 0xa4, 0x61, 0xa8, 0xa2,
	0x50, 0xdb, 0xb6, 0x69, 0x26, 0x92, 0x1e, 0xac, 0x4f, 0xf0, 0xbd, 0x45, 0x5e, 0x7d, 0xaa, 0xc6,
	0x7b, 0x99, 0x24, 0x71, 0x72, 0x89, 0x42, 0x04, 0x33, 0x03, 0x79, 0x87, 0x96, 0x74, 0xfe, 0x39,
	0xf4, 0x7e, 0xbf, 0x8c, 0x02, 0x69, 0x4f, 0x57, 0x97, 0xca, 0x11, 0xb4, 0x8c, 0x2e, 0x2b, 0x93,
	0x27, 0x45, 0x99, 0xb8, 0xc6, 0x34, 0x33, 0xf3, 0xff, 0xd5, 0x80, 0xae, 0xbb, 0xa2, 0x8e, 0xfa,
	0x3a, 0x96, 0xc1, 0x7c, 0xc2, 0xfe, 0x6c, 0x12, 0xdd, 0xa0, 0x85, 0xa2, 0x58, 0x45, 0x2e, 0x75,
	0x54, 0xf9, 0x2a, 0x72, 0xa9, 0x56, 0x87, 0xf1, 0x62, 0x39, 0x47, 0xd5, 0x6f, 0x1b, 0x3a, 0xc9,
	0x42, 0xe1, 0x02, 0xb0, 0x59, 0x06, 0xa0, 0x0f, 0x6d, 0x93, 0x9a, 0x98, 0xe9, 0x32, 0xe8, 0xd0,
	0x5c, 0xce, 0xfa, 0xd4, 0xc4, 0x18, 0xd9, 0x2a, 0x70, 0x55, 0xfe, 0x53, 0xd8, 0x2b, 0xe5, 0xa6,
	0x4a, 0x4b, 0xc8, 0x2a, 0x3d, 0xf8, 0xbf, 0x83, 0x5d, 0x63, 0x46, 0x71, 0x8a, 0x89, 0x2e, 0xbe,
	0x2a, 0x83, 0x0c, 0xa0, 0x69, 0xf6, 0xd0, 0x89, 0xdf, 0x8f, 0x9e, 0xb5, 0xf2, 0xff, 0xd6, 0x00,
	0x50, 0xb5, 0x31, 0x8c, 0xf9, 0x94, 0xcd, 0x54, 0x1a, 0xe7, 0x78, 0x93, 0xce, 0xae, 0x87, 0x63,
	0x7b, 0xc4, 0xb9, 0xac, 0xd2, 0xd0, 0xdf, 0x9a, 0xba, 0x12, 0xbd, 0x7f, 0x9b, 0xba, 0x2a, 0x72,
	0x04, 0x7b, 0x5a, 0x54, 0x2d, 0xcc, 0x83, 0xe8, 0x75, 0xc0, 0xa3, 0x39, 0x26, 0x1a, 0xe4, 0x36,
	0xad, 0x5b, 0x52, 0xbd, 0x7b, 0x11, 0x27, 0x21, 0x8e, 0x78, 0xc4, 0x12, 0x0c, 0xa5, 0x85, 0xbc,
	0xac, 0xf4, 0xff, 0xdb, 0x80, 0xa6, 0x0d, 0xf0, 0x19, 0xec, 0x5c, 0x0f, 0xc7, 0x13, 0xc6, 0x67,
	0x73, 0xd4, 0xbf, 0x6a, 0xc3, 0xac, 0x68, 0xc9, 0x10, 0xb6, 0x8a, 0xb4, 0x0c, 0x3f, 0x6d, 0x1d,
	0x7f, 0xee, 0x32, 0x8e, 0x5a, 0x18, 0x38, 0x36, 0x2f, 0xb9, 0x4c, 0x6e, 0xa9, 0xeb, 0xa5, 0xf2,
	0x19, 0x07, 0x42, 0xb0, 0x15, 0xaa, 0x78, 0xc5, 0xb7, 0xc1, 0x3b, 0x54, 0xc0, 0xd8, 0x7c, 0x6a,
	0x96, 0xfa, 0xd7, 0xd0, 0xab, 0x6e, 0xa9, 0x7a, 0xe3, 0x1d, 0xde, 0xda, 0x46, 0x54, 0x9f, 0xe4,
	0x4b, 0xd8, 0x5c, 0x05, 0xf3, 0x14, 0xed, 0x19, 0x39, 0x44, 0x58, 0x38, 0x53, 0x63, 0xf2, 0xab,
	0xb5, 0x17, 0x0d, 0xdf, 0x83, 0xb5, 0xd1, 0x58, 0x5f, 0x0e, 0xe3, 0xd5, 0x73, 0xbd, 0x91, 0xba,
	0x1c, 0xc6, 0xab, 0xe7, 0xfe, 0x00, 0x88, 0xa1, 0x39, 0xe5, 0x98, 0xd7, 0x8d, 0x07, 0x2d, 0x43,
	0xdf, 0xa6, 0x87, 0xb6, 0x69, 0x26, 0xfa, 0xaf, 0x60, 0xaf, 0x64, 0x2f, 0x96, 0x31, 0x17, 0x48,
	0x8e, 0x60, 0x53, 0x2b, 0x6c, 0xcb, 0xf5, 0x8b, 0x80, 0x0a, 0x6b, 0x5b, 0x38, 0xc6, 0xd0, 0xff,
	0x4b, 0x03, 0x7a, 0xd5, 0xb5, 0xfb, 0x2e, 0x60, 0xc3, 0x77, 0x21, 0xb2, 0x15, 0x46, 0x96, 0x22,
	0x4a, 0x3a, 0x55, 0x75, 0x4a, 0xce, 0x3b, 0x72, 0x9b, 0xe6, 0x72, 0x89, 0x79, 0x37, 0x74, 0x99,
	0xe7, 0xb2, 0x7f, 0x05, 0x8f, 0xae, 0x87, 0xe3, 0x61, 0xcc, 0x39, 0x86, 0x8a, 0xf4, 0x34, 0x81,
	0xfc, 0x52, 0xdd, 0x35, 0x99, 0x26, 0xcb, 0xe8, 0x93, 0x22, 0xa3, 0x92, 0x07, 0x75, 0x6d, 0xfd,
	0xff, 0xac, 0xc1, 0x76, 0x69, 0xb9, 0xf4, 0xeb, 0x8d, 0xf2, 0xaf, 0xab, 0x6c, 0xc7, 0x68, 0x1b,
	0xa1, 0x43, 0xf5, 0xb7, 0xe2, 0xd1, 0xb3, 0x44, 0xf3, 0xb8, 0x29, 0x12, 0x2b, 0xa9, 0x7d, 0x2e,
	0x02, 0x36, 0x4f, 0x13, 0x14, 0xf6, 0x76, 0xc9, 0x65, 0xe5, 0x53, 0xba, 0x9f, 0xad, 0x74, 0x07,
	0xb9, 0x66, 0x0d, 0x72, 0xce, 0x70, 0xd0, 0x2a, 0x0f, 0x07, 0x1e, 0xb4, 0x54, 0x27, 0x30, 0x3e,
	0xd3, 0x57, 0x4a, 0x9b, 0x66, 0xa2, 0xa9, 0xea, 0x44, 0x60, 0x32, 0x4c, 0x93, 0x04, 0xb9, 0x3c,
	0x4b, 0xa7, 0x53, 0x4c, 0xf4, 0xbd, 0xd2, 0xa5, 0x75, 0x4b, 0xe4, 0x00, 0x76, 0x8d, 0x7a, 0x24,
	0x5e, 0x8a, 0x30, 0x58, 0x62, 0xe4, 0x81, 0xde, 0xb3, 0xaa, 0x76, 0x2d, 0x27, 0x32, 0x48, 0x54,
	0x5c, 0x5b, 0x65, 0x4b, 0xab, 0xf6, 0xff, 0xd9, 0x80, 0x4f, 0xd4, 0xd5, 0xf2, 0x96, 0xc9, 0x6f,
	0xb3, 0x3a, 0xcc, 0xea, 0xf7, 0x29, 0xac, 0x0f, 0xe3, 0x85, 0x06, 0x7c, 0xeb, 0x78, 0xcf, 0x1d,
	0x31, 0xed, 0x70, 0x40, 0xd5, 0xba, 0xe2, 0xea, 0xcb, 0xe0, 0xbb, 0xb7, 0x01, 0x93, 0x97, 0x13,
	0x5b, 0x57, 0x85, 0x42, 0xc1, 0x77, 0x19, 0x7c, 0x97, 0x6d, 0x2d, 0x6c, 0x61, 0x95, 0x74, 0x8a,
	0x4d, 0xac, 0x83, 0x9e, 0x89, 0x2e, 0x27, 0xf6, 0x70, 0x2a, 0x5a, 0xff, 0x4f, 0xd0, 0xce, 0x7b,
	0x45, 0xed, 0xcb, 0xe6, 0x73, 0x26, 0x30, 0x8c, 0x79, 0x24, 0x6c, 0xb1, 0x97, 0x74, 0xe4, 0xb0,
	0xb0, 0xb7, 0x3d, 0x5e, 0x9b, 0x45, 0x6e, 0xe4, 0xff, 0xb5, 0x01, 0x4f, 0xee, 0xa2, 0xa1, 0x2f,
	0xdd, 0x2f, 0x60, 0x43, 0x37, 0xc6, 0x03, 0x68, 0x68, 0x83, 0x9a, 0x3b, 0xf8, 0x08, 0x3a, 0x6e,
	0xfe, 0xaa, 0x11, 0x88, 0x33, 0x94, 0x66, 0xbf, 0x53, 0x18, 0x29, 0x3e, 0x39, 0xd7, 0x9c, 0x6b,
	0x26, 0xd6, 0xff, 0xcb, 0x27, 0xd7, 0x99, 0xbd, 0x52, 0xe4, 0x10, 0x15, 0x15, 0xdd, 0x28, 0x55,
	0xf4, 0x33, 0xd8, 0x29, 0x76, 0x0f, 0x6e, 0xec, 0x18, 0xd2, 0xa6, 0x15, 0xad, 0x3f, 0x82, 0xbd,
	0x52, 0x14, 0x76, 0xdb, 0xe3, 0x32, 0x4b, 0x7d, 0x5a, 0xa4, 0x72, 0x37, 0x86, 0x8c, 0xa7, 0x76,
	0x61, 0x5b, 0xb1, 0x02, 0x72, 0x9b, 0x8b, 0x9f, 0x42, 0xd7, 0x28, 0x26, 0x32, 0xc1, 0x60, 0xa1,
	0x72, 0xcb, 0x06, 0x68, 0x3b, 0xd3, 0x64, 0xc3, 0xf3, 0x4f, 0xa1, 0x65, 0x01, 0x7e, 0xe8, 0x0c,
	0x33, 0x1b, 0x3d, 0x57, 0xb0, 0x05, 0x0a, 0x19, 0x2c, 0x96, 0xd9, 0x80, 0x99, 0x2b, 0x7c, 0x1f,
	0x76, 0x32, 0xe2, 0xb8, 0x4a, 0x17, 0x37, 0x98, 0x64, 0xc7, 0xd5, 0xc8, 0x8f, 0xeb, 0xf8, 0xdf,
	0x00, 0xed, 0xc9, 0x70, 0xa2, 0x53, 0x22, 0x27, 0xd0, 0x53, 0x71, 0xfe, 0x96, 0xc7, 0x1f, 0xb8,
	0x7d, 0x6e, 0x90, 0xee, 0xc0, 0x3e, 0x8d, 0xbe, 0x89, 0x59, 0xd4, 0x7f, 0x5c, 0x7d, 0x97, 0x68,
	0xfa, 0x7b, 0x01, 0xbb, 0xb9, 0x9f, 0x79, 0x6f, 0x90, 0x3b, 0x0f, 0x98, 0xfe, 0x5e, 0xe5, 0x69,
	0xa2, 0x3d, 0x0f, 0x75, 0xa1, 0x45, 0xa4, 0x2e, 0xcd, 0x3e, 0x71, 0x95, 0x96, 0xee, 0x7f, 0xae,
	0xc8, 0x91, 0x47, 0x93, 0x5b, 0x1e, 0xd6, 0x3b, 0x39, 0x11, 0x3a, 0x53, 0xe4, 0x09, 0x74, 0x94,
	0x74, 0x2a, 0x3e, 0xd2, 0xef, 0x2b, 0x78, 0x94, 0x67, 0x66, 0x2d, 0xab, 0x90, 0x78, 0x75, 0x4f,
	0x0a, 0x9d, 0xdc, 0x2f, 0xa0, 0xab, 0x99, 0xe7, 0x25, 0x7f, 0x9f, 0xb2, 0xe4, 0x96, 0xec, 0xdd,
	0x79, 0xd4, 0xe1, 0xb4, 0x36, 0xc9, 0xaf, 0x61, 0xf7, 0x15, 0xca, 0xd2, 0x23, 0xa4, 0xd6, 0xf7,
	0x49, 0x55, 0x69, 0x8d, 0x7f, 0x03, 0x8f, 0xcc, 0xe0, 0xa5, 0x47, 0x6d, 0x33, 0xa4, 0x13, 0xe7,
	0x82, 0xad, 0x0e, 0xee, 0xfd, 0xef, 0x55, 0x27, 0xb6, 0x62, 0xd8, 0x7b, 0xad, 0x63, 0x29, 0xcd,
	0xba, 0x9f, 0xdd, 0x33, 0xdf, 0x99, 0x6a, 0xef, 0xdf, 0x33, 0xfe, 0x91, 0x13, 0x80, 0x7c, 0xa7,
	0x2a, 0x88, 0xfd, 0x7a, 0x1f, 0x5b, 0x23, 0x5b, 0xa7, 0x51, 0xa4, 0x14, 0x2c, 0x1c, 0x8d, 0x49,
	0xb7, 0x30, 0x1d, 0x8d, 0x6b, 0xe1, 0x3b, 0x86, 0x1d, 0x8a, 0x8b, 0x78, 0x85, 0x1f, 0xe1, 0xf3,
	0x13, 0xe8, 0xbc, 0x42, 0x69, 0x07, 0xbe, 0x72, 0x6c, 0xbd, 0xea, 0x04, 0x47, 0x0e, 0x55, 0x35,
	0x65, 0xc6, 0x77, 0x96, 0x6b, 0x1c, 0xae, 0x34, 0x88, 0x66, 0x76, 0xc9, 0x1e, 0x0c, 0x75, 0xf3,
	0x4e, 0x8e, 0xe1, 0x67, 0xf7, 0xac, 0x5a, 0x56, 0xfa, 0x1a, 0x1e, 0xbd, 0x42, 0x59, 0x1a, 0x1b,
	0xaa, 0x88, 0x7e, 0xff, 0x9e, 0xe9, 0x43, 0x43, 0xfa, 0x16, 0x7a, 0x55, 0xe6, 0x27, 0x9f, 0x97,
	0x1b, 0xa0, 0xe6, 0x8e, 0xec, 0xef, 0x3f, 0x64, 0xa2, 0xfb, 0x65, 0x02, 0x8f, 0x1d, 0x16, 0x3d,
	0x5d, 0x05, 0x6c, 0xae, 0xd8, 0x95, 0xdc, 0xe1, 0x4d, 0x97, 0xeb, 0xdd, 0x6c, 0xeb, 0x38, 0xf8,
	0x2b, 0x68, 0x1a, 0xfa, 0x24, 0xce, 0x48, 0x55, 0x62, 0x58, 0xb7, 0xe6, 0x5c, 0xa6, 0x3d, 0x6a,
	0x90, 0xe7, 0xea, 0x95, 0xad, 0x97, 0xd4, 0xed, 0x74, 0x6f, 0xeb, 0x56, 0x88, 0xf2, 0x10, 0xe0,
	0x9c, 0x89, 0xd0, 0xa0, 0x56, 0xdf, 0x7c, 0xa5, 0xad, 0xce, 0x9e, 0xc2, 0x8f, 0x38, 0x4a, 0xb7,
	0xb0, 0xec, 0xff, 0x9c, 0x82, 0x25, 0x13, 0xb9, 0xfb, 0x4d, 0x53, 0xff, 0x83, 0xe9, 0x67, 0xff,
	0x0b, 0x00, 0x00, 0xff, 0xff, 0xcc, 0x9d, 0x14, 0x22, 0x08, 0x13, 0x00, 0x00,
}
