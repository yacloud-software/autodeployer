// Code generated by protoc-gen-go.
// source: golang.conradwood.net/apis/buildrepo/buildrepo.proto
// DO NOT EDIT!

/*
Package buildrepo is a generated protocol buffer package.

It is generated from these files:
	golang.conradwood.net/apis/buildrepo/buildrepo.proto

It has these top-level messages:
	CreateBuildRequest
	CreateBuildResponse
	UploadTokenRequest
	UploadTokenResponse
	UploadDoneRequest
	UploadDoneResponse
	RepoEntry
	ListReposRequest
	ListReposResponse
	ListBranchesRequest
	ListBranchesResponse
	ListVersionsRequest
	ListVersionsResponse
	ListFilesRequest
	ListFilesResponse
	GetLatestVersionRequest
	GetLatestVersionResponse
	BuildMeta
	GetBlockRequest
	GetBlockResponse
	File
	Tool
	ListToolsResponse
	GetFileRequest
	FileBlock
	GetMetaRequest
	GetMetaResponse
	RepoDef
	BuildNumber
	BuildDef
	BuildInfo
	FilePattern
	FileList
	FileExistsInfo
	GetRepoMetaRequest
	RepoMetaInfo
*/
package buildrepo

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import common "golang.conradwood.net/apis/common"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type CreateBuildRequest struct {
	// deprecated - use repo id instead
	Repository   string `protobuf:"bytes,1,opt,name=Repository" json:"Repository,omitempty"`
	CommitID     string `protobuf:"bytes,2,opt,name=CommitID" json:"CommitID,omitempty"`
	Branch       string `protobuf:"bytes,3,opt,name=Branch" json:"Branch,omitempty"`
	BuildID      uint64 `protobuf:"varint,4,opt,name=BuildID" json:"BuildID,omitempty"`
	CommitMSG    string `protobuf:"bytes,5,opt,name=CommitMSG" json:"CommitMSG,omitempty"`
	UserEmail    string `protobuf:"bytes,6,opt,name=UserEmail" json:"UserEmail,omitempty"`
	RepositoryID uint64 `protobuf:"varint,7,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	// the artefact name - under which path to save it
	ArtefactName string `protobuf:"bytes,8,opt,name=ArtefactName" json:"ArtefactName,omitempty"`
}

func (m *CreateBuildRequest) Reset()                    { *m = CreateBuildRequest{} }
func (m *CreateBuildRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateBuildRequest) ProtoMessage()               {}
func (*CreateBuildRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *CreateBuildRequest) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

func (m *CreateBuildRequest) GetCommitID() string {
	if m != nil {
		return m.CommitID
	}
	return ""
}

func (m *CreateBuildRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *CreateBuildRequest) GetBuildID() uint64 {
	if m != nil {
		return m.BuildID
	}
	return 0
}

func (m *CreateBuildRequest) GetCommitMSG() string {
	if m != nil {
		return m.CommitMSG
	}
	return ""
}

func (m *CreateBuildRequest) GetUserEmail() string {
	if m != nil {
		return m.UserEmail
	}
	return ""
}

func (m *CreateBuildRequest) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *CreateBuildRequest) GetArtefactName() string {
	if m != nil {
		return m.ArtefactName
	}
	return ""
}

type CreateBuildResponse struct {
	BuildStoreid string `protobuf:"bytes,1,opt,name=BuildStoreid" json:"BuildStoreid,omitempty"`
}

func (m *CreateBuildResponse) Reset()                    { *m = CreateBuildResponse{} }
func (m *CreateBuildResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateBuildResponse) ProtoMessage()               {}
func (*CreateBuildResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *CreateBuildResponse) GetBuildStoreid() string {
	if m != nil {
		return m.BuildStoreid
	}
	return ""
}

type UploadTokenRequest struct {
	BuildStoreid string `protobuf:"bytes,1,opt,name=BuildStoreid" json:"BuildStoreid,omitempty"`
	Filename     string `protobuf:"bytes,2,opt,name=Filename" json:"Filename,omitempty"`
	UserEmail    string `protobuf:"bytes,3,opt,name=UserEmail" json:"UserEmail,omitempty"`
}

func (m *UploadTokenRequest) Reset()                    { *m = UploadTokenRequest{} }
func (m *UploadTokenRequest) String() string            { return proto.CompactTextString(m) }
func (*UploadTokenRequest) ProtoMessage()               {}
func (*UploadTokenRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *UploadTokenRequest) GetBuildStoreid() string {
	if m != nil {
		return m.BuildStoreid
	}
	return ""
}

func (m *UploadTokenRequest) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func (m *UploadTokenRequest) GetUserEmail() string {
	if m != nil {
		return m.UserEmail
	}
	return ""
}

type UploadTokenResponse struct {
	Token string `protobuf:"bytes,1,opt,name=Token" json:"Token,omitempty"`
}

func (m *UploadTokenResponse) Reset()                    { *m = UploadTokenResponse{} }
func (m *UploadTokenResponse) String() string            { return proto.CompactTextString(m) }
func (*UploadTokenResponse) ProtoMessage()               {}
func (*UploadTokenResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *UploadTokenResponse) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

type UploadDoneRequest struct {
	BuildStoreid string `protobuf:"bytes,1,opt,name=BuildStoreid" json:"BuildStoreid,omitempty"`
}

func (m *UploadDoneRequest) Reset()                    { *m = UploadDoneRequest{} }
func (m *UploadDoneRequest) String() string            { return proto.CompactTextString(m) }
func (*UploadDoneRequest) ProtoMessage()               {}
func (*UploadDoneRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *UploadDoneRequest) GetBuildStoreid() string {
	if m != nil {
		return m.BuildStoreid
	}
	return ""
}

type UploadDoneResponse struct {
	Closed    bool   `protobuf:"varint,1,opt,name=Closed" json:"Closed,omitempty"`
	Uploading uint32 `protobuf:"varint,2,opt,name=Uploading" json:"Uploading,omitempty"`
}

func (m *UploadDoneResponse) Reset()                    { *m = UploadDoneResponse{} }
func (m *UploadDoneResponse) String() string            { return proto.CompactTextString(m) }
func (*UploadDoneResponse) ProtoMessage()               {}
func (*UploadDoneResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *UploadDoneResponse) GetClosed() bool {
	if m != nil {
		return m.Closed
	}
	return false
}

func (m *UploadDoneResponse) GetUploading() uint32 {
	if m != nil {
		return m.Uploading
	}
	return 0
}

type RepoEntry struct {
	Name        string                    `protobuf:"bytes,1,opt,name=Name" json:"Name,omitempty"`
	Type        int32                     `protobuf:"varint,2,opt,name=Type" json:"Type,omitempty"`
	Dir         string                    `protobuf:"bytes,3,opt,name=Dir" json:"Dir,omitempty"`
	Domain      string                    `protobuf:"bytes,4,opt,name=Domain" json:"Domain,omitempty"`
	LatestBuild *GetLatestVersionResponse `protobuf:"bytes,5,opt,name=LatestBuild" json:"LatestBuild,omitempty"`
}

func (m *RepoEntry) Reset()                    { *m = RepoEntry{} }
func (m *RepoEntry) String() string            { return proto.CompactTextString(m) }
func (*RepoEntry) ProtoMessage()               {}
func (*RepoEntry) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *RepoEntry) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RepoEntry) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *RepoEntry) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *RepoEntry) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *RepoEntry) GetLatestBuild() *GetLatestVersionResponse {
	if m != nil {
		return m.LatestBuild
	}
	return nil
}

type ListReposRequest struct {
}

func (m *ListReposRequest) Reset()                    { *m = ListReposRequest{} }
func (m *ListReposRequest) String() string            { return proto.CompactTextString(m) }
func (*ListReposRequest) ProtoMessage()               {}
func (*ListReposRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type ListReposResponse struct {
	Entries []*RepoEntry `protobuf:"bytes,1,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *ListReposResponse) Reset()                    { *m = ListReposResponse{} }
func (m *ListReposResponse) String() string            { return proto.CompactTextString(m) }
func (*ListReposResponse) ProtoMessage()               {}
func (*ListReposResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *ListReposResponse) GetEntries() []*RepoEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type ListBranchesRequest struct {
	Repository string `protobuf:"bytes,1,opt,name=Repository" json:"Repository,omitempty"`
}

func (m *ListBranchesRequest) Reset()                    { *m = ListBranchesRequest{} }
func (m *ListBranchesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListBranchesRequest) ProtoMessage()               {}
func (*ListBranchesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ListBranchesRequest) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

type ListBranchesResponse struct {
	Entries []*RepoEntry `protobuf:"bytes,1,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *ListBranchesResponse) Reset()                    { *m = ListBranchesResponse{} }
func (m *ListBranchesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListBranchesResponse) ProtoMessage()               {}
func (*ListBranchesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *ListBranchesResponse) GetEntries() []*RepoEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type ListVersionsRequest struct {
	Repository string `protobuf:"bytes,1,opt,name=Repository" json:"Repository,omitempty"`
	Branch     string `protobuf:"bytes,2,opt,name=Branch" json:"Branch,omitempty"`
}

func (m *ListVersionsRequest) Reset()                    { *m = ListVersionsRequest{} }
func (m *ListVersionsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListVersionsRequest) ProtoMessage()               {}
func (*ListVersionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *ListVersionsRequest) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

func (m *ListVersionsRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

type ListVersionsResponse struct {
	Entries []*RepoEntry `protobuf:"bytes,1,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *ListVersionsResponse) Reset()                    { *m = ListVersionsResponse{} }
func (m *ListVersionsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListVersionsResponse) ProtoMessage()               {}
func (*ListVersionsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *ListVersionsResponse) GetEntries() []*RepoEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type ListFilesRequest struct {
	Repository string `protobuf:"bytes,1,opt,name=Repository" json:"Repository,omitempty"`
	Branch     string `protobuf:"bytes,2,opt,name=Branch" json:"Branch,omitempty"`
	BuildID    uint64 `protobuf:"varint,3,opt,name=BuildID" json:"BuildID,omitempty"`
	Dir        string `protobuf:"bytes,4,opt,name=Dir" json:"Dir,omitempty"`
	Recursive  bool   `protobuf:"varint,5,opt,name=Recursive" json:"Recursive,omitempty"`
}

func (m *ListFilesRequest) Reset()                    { *m = ListFilesRequest{} }
func (m *ListFilesRequest) String() string            { return proto.CompactTextString(m) }
func (*ListFilesRequest) ProtoMessage()               {}
func (*ListFilesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *ListFilesRequest) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

func (m *ListFilesRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *ListFilesRequest) GetBuildID() uint64 {
	if m != nil {
		return m.BuildID
	}
	return 0
}

func (m *ListFilesRequest) GetDir() string {
	if m != nil {
		return m.Dir
	}
	return ""
}

func (m *ListFilesRequest) GetRecursive() bool {
	if m != nil {
		return m.Recursive
	}
	return false
}

type ListFilesResponse struct {
	Entries []*RepoEntry `protobuf:"bytes,1,rep,name=Entries" json:"Entries,omitempty"`
}

func (m *ListFilesResponse) Reset()                    { *m = ListFilesResponse{} }
func (m *ListFilesResponse) String() string            { return proto.CompactTextString(m) }
func (*ListFilesResponse) ProtoMessage()               {}
func (*ListFilesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *ListFilesResponse) GetEntries() []*RepoEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type GetLatestVersionRequest struct {
	Repository string `protobuf:"bytes,1,opt,name=Repository" json:"Repository,omitempty"`
	Branch     string `protobuf:"bytes,2,opt,name=Branch" json:"Branch,omitempty"`
}

func (m *GetLatestVersionRequest) Reset()                    { *m = GetLatestVersionRequest{} }
func (m *GetLatestVersionRequest) String() string            { return proto.CompactTextString(m) }
func (*GetLatestVersionRequest) ProtoMessage()               {}
func (*GetLatestVersionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *GetLatestVersionRequest) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

func (m *GetLatestVersionRequest) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

type GetLatestVersionResponse struct {
	BuildID   uint64     `protobuf:"varint,1,opt,name=BuildID" json:"BuildID,omitempty"`
	BuildMeta *BuildMeta `protobuf:"bytes,2,opt,name=BuildMeta" json:"BuildMeta,omitempty"`
}

func (m *GetLatestVersionResponse) Reset()                    { *m = GetLatestVersionResponse{} }
func (m *GetLatestVersionResponse) String() string            { return proto.CompactTextString(m) }
func (*GetLatestVersionResponse) ProtoMessage()               {}
func (*GetLatestVersionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GetLatestVersionResponse) GetBuildID() uint64 {
	if m != nil {
		return m.BuildID
	}
	return 0
}

func (m *GetLatestVersionResponse) GetBuildMeta() *BuildMeta {
	if m != nil {
		return m.BuildMeta
	}
	return nil
}

// metadata about this repo
type BuildMeta struct {
	RepositoryID uint64 `protobuf:"varint,1,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
	CommitID     string `protobuf:"bytes,2,opt,name=CommitID" json:"CommitID,omitempty"`
	Branch       string `protobuf:"bytes,3,opt,name=Branch" json:"Branch,omitempty"`
}

func (m *BuildMeta) Reset()                    { *m = BuildMeta{} }
func (m *BuildMeta) String() string            { return proto.CompactTextString(m) }
func (*BuildMeta) ProtoMessage()               {}
func (*BuildMeta) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *BuildMeta) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func (m *BuildMeta) GetCommitID() string {
	if m != nil {
		return m.CommitID
	}
	return ""
}

func (m *BuildMeta) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

type GetBlockRequest struct {
	File   *File  `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	Offset uint64 `protobuf:"varint,2,opt,name=Offset" json:"Offset,omitempty"`
	Size   uint32 `protobuf:"varint,3,opt,name=Size" json:"Size,omitempty"`
}

func (m *GetBlockRequest) Reset()                    { *m = GetBlockRequest{} }
func (m *GetBlockRequest) String() string            { return proto.CompactTextString(m) }
func (*GetBlockRequest) ProtoMessage()               {}
func (*GetBlockRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *GetBlockRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *GetBlockRequest) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *GetBlockRequest) GetSize() uint32 {
	if m != nil {
		return m.Size
	}
	return 0
}

type GetBlockResponse struct {
	File   *File  `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	Offset uint64 `protobuf:"varint,2,opt,name=Offset" json:"Offset,omitempty"`
	Size   uint32 `protobuf:"varint,3,opt,name=Size" json:"Size,omitempty"`
	Data   []byte `protobuf:"bytes,4,opt,name=Data,proto3" json:"Data,omitempty"`
}

func (m *GetBlockResponse) Reset()                    { *m = GetBlockResponse{} }
func (m *GetBlockResponse) String() string            { return proto.CompactTextString(m) }
func (*GetBlockResponse) ProtoMessage()               {}
func (*GetBlockResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *GetBlockResponse) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *GetBlockResponse) GetOffset() uint64 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *GetBlockResponse) GetSize() uint32 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *GetBlockResponse) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// identify a unique file
type File struct {
	Repository string `protobuf:"bytes,1,opt,name=Repository" json:"Repository,omitempty"`
	Branch     string `protobuf:"bytes,2,opt,name=Branch" json:"Branch,omitempty"`
	BuildID    uint64 `protobuf:"varint,3,opt,name=BuildID" json:"BuildID,omitempty"`
	Filename   string `protobuf:"bytes,4,opt,name=Filename" json:"Filename,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *File) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

func (m *File) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *File) GetBuildID() uint64 {
	if m != nil {
		return m.BuildID
	}
	return 0
}

func (m *File) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

type Tool struct {
	Repository string `protobuf:"bytes,1,opt,name=Repository" json:"Repository,omitempty"`
	Filename   string `protobuf:"bytes,2,opt,name=Filename" json:"Filename,omitempty"`
}

func (m *Tool) Reset()                    { *m = Tool{} }
func (m *Tool) String() string            { return proto.CompactTextString(m) }
func (*Tool) ProtoMessage()               {}
func (*Tool) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *Tool) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

func (m *Tool) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

type ListToolsResponse struct {
	Tools []*Tool `protobuf:"bytes,1,rep,name=Tools" json:"Tools,omitempty"`
}

func (m *ListToolsResponse) Reset()                    { *m = ListToolsResponse{} }
func (m *ListToolsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListToolsResponse) ProtoMessage()               {}
func (*ListToolsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *ListToolsResponse) GetTools() []*Tool {
	if m != nil {
		return m.Tools
	}
	return nil
}

type GetFileRequest struct {
	File      *File  `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	Blocksize uint32 `protobuf:"varint,2,opt,name=Blocksize" json:"Blocksize,omitempty"`
}

func (m *GetFileRequest) Reset()                    { *m = GetFileRequest{} }
func (m *GetFileRequest) String() string            { return proto.CompactTextString(m) }
func (*GetFileRequest) ProtoMessage()               {}
func (*GetFileRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *GetFileRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *GetFileRequest) GetBlocksize() uint32 {
	if m != nil {
		return m.Blocksize
	}
	return 0
}

// response to above request : chunk of bytes, to be streamed
type FileBlock struct {
	Size        uint64 `protobuf:"varint,1,opt,name=Size" json:"Size,omitempty"`
	Data        []byte `protobuf:"bytes,2,opt,name=Data,proto3" json:"Data,omitempty"`
	UploadToken string `protobuf:"bytes,3,opt,name=UploadToken" json:"UploadToken,omitempty"`
}

func (m *FileBlock) Reset()                    { *m = FileBlock{} }
func (m *FileBlock) String() string            { return proto.CompactTextString(m) }
func (*FileBlock) ProtoMessage()               {}
func (*FileBlock) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{24} }

func (m *FileBlock) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

func (m *FileBlock) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *FileBlock) GetUploadToken() string {
	if m != nil {
		return m.UploadToken
	}
	return ""
}

type GetMetaRequest struct {
	File *File `protobuf:"bytes,1,opt,name=File" json:"File,omitempty"`
}

func (m *GetMetaRequest) Reset()                    { *m = GetMetaRequest{} }
func (m *GetMetaRequest) String() string            { return proto.CompactTextString(m) }
func (*GetMetaRequest) ProtoMessage()               {}
func (*GetMetaRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{25} }

func (m *GetMetaRequest) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

type GetMetaResponse struct {
	File *File  `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	Size uint64 `protobuf:"varint,2,opt,name=Size" json:"Size,omitempty"`
}

func (m *GetMetaResponse) Reset()                    { *m = GetMetaResponse{} }
func (m *GetMetaResponse) String() string            { return proto.CompactTextString(m) }
func (*GetMetaResponse) ProtoMessage()               {}
func (*GetMetaResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{26} }

func (m *GetMetaResponse) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *GetMetaResponse) GetSize() uint64 {
	if m != nil {
		return m.Size
	}
	return 0
}

type RepoDef struct {
	Repository string `protobuf:"bytes,1,opt,name=Repository" json:"Repository,omitempty"`
	Branch     string `protobuf:"bytes,2,opt,name=Branch" json:"Branch,omitempty"`
}

func (m *RepoDef) Reset()                    { *m = RepoDef{} }
func (m *RepoDef) String() string            { return proto.CompactTextString(m) }
func (*RepoDef) ProtoMessage()               {}
func (*RepoDef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{27} }

func (m *RepoDef) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

func (m *RepoDef) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

type BuildNumber struct {
	BuildID uint64 `protobuf:"varint,1,opt,name=BuildID" json:"BuildID,omitempty"`
}

func (m *BuildNumber) Reset()                    { *m = BuildNumber{} }
func (m *BuildNumber) String() string            { return proto.CompactTextString(m) }
func (*BuildNumber) ProtoMessage()               {}
func (*BuildNumber) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{28} }

func (m *BuildNumber) GetBuildID() uint64 {
	if m != nil {
		return m.BuildID
	}
	return 0
}

type BuildDef struct {
	Repository string `protobuf:"bytes,1,opt,name=Repository" json:"Repository,omitempty"`
	Branch     string `protobuf:"bytes,2,opt,name=Branch" json:"Branch,omitempty"`
	BuildID    uint64 `protobuf:"varint,3,opt,name=BuildID" json:"BuildID,omitempty"`
}

func (m *BuildDef) Reset()                    { *m = BuildDef{} }
func (m *BuildDef) String() string            { return proto.CompactTextString(m) }
func (*BuildDef) ProtoMessage()               {}
func (*BuildDef) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{29} }

func (m *BuildDef) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

func (m *BuildDef) GetBranch() string {
	if m != nil {
		return m.Branch
	}
	return ""
}

func (m *BuildDef) GetBuildID() uint64 {
	if m != nil {
		return m.BuildID
	}
	return 0
}

type BuildInfo struct {
	CommitID      string `protobuf:"bytes,1,opt,name=CommitID" json:"CommitID,omitempty"`
	CommitMessage string `protobuf:"bytes,2,opt,name=CommitMessage" json:"CommitMessage,omitempty"`
	UserEmail     string `protobuf:"bytes,3,opt,name=UserEmail" json:"UserEmail,omitempty"`
	BuildDate     uint32 `protobuf:"varint,4,opt,name=BuildDate" json:"BuildDate,omitempty"`
}

func (m *BuildInfo) Reset()                    { *m = BuildInfo{} }
func (m *BuildInfo) String() string            { return proto.CompactTextString(m) }
func (*BuildInfo) ProtoMessage()               {}
func (*BuildInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{30} }

func (m *BuildInfo) GetCommitID() string {
	if m != nil {
		return m.CommitID
	}
	return ""
}

func (m *BuildInfo) GetCommitMessage() string {
	if m != nil {
		return m.CommitMessage
	}
	return ""
}

func (m *BuildInfo) GetUserEmail() string {
	if m != nil {
		return m.UserEmail
	}
	return ""
}

func (m *BuildInfo) GetBuildDate() uint32 {
	if m != nil {
		return m.BuildDate
	}
	return 0
}

type FilePattern struct {
	Pattern string `protobuf:"bytes,1,opt,name=Pattern" json:"Pattern,omitempty"`
}

func (m *FilePattern) Reset()                    { *m = FilePattern{} }
func (m *FilePattern) String() string            { return proto.CompactTextString(m) }
func (*FilePattern) ProtoMessage()               {}
func (*FilePattern) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{31} }

func (m *FilePattern) GetPattern() string {
	if m != nil {
		return m.Pattern
	}
	return ""
}

type FileList struct {
	Files []*File `protobuf:"bytes,1,rep,name=Files" json:"Files,omitempty"`
}

func (m *FileList) Reset()                    { *m = FileList{} }
func (m *FileList) String() string            { return proto.CompactTextString(m) }
func (*FileList) ProtoMessage()               {}
func (*FileList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{32} }

func (m *FileList) GetFiles() []*File {
	if m != nil {
		return m.Files
	}
	return nil
}

type FileExistsInfo struct {
	Exists bool `protobuf:"varint,1,opt,name=Exists" json:"Exists,omitempty"`
}

func (m *FileExistsInfo) Reset()                    { *m = FileExistsInfo{} }
func (m *FileExistsInfo) String() string            { return proto.CompactTextString(m) }
func (*FileExistsInfo) ProtoMessage()               {}
func (*FileExistsInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{33} }

func (m *FileExistsInfo) GetExists() bool {
	if m != nil {
		return m.Exists
	}
	return false
}

type GetRepoMetaRequest struct {
	Path string `protobuf:"bytes,1,opt,name=Path" json:"Path,omitempty"`
}

func (m *GetRepoMetaRequest) Reset()                    { *m = GetRepoMetaRequest{} }
func (m *GetRepoMetaRequest) String() string            { return proto.CompactTextString(m) }
func (*GetRepoMetaRequest) ProtoMessage()               {}
func (*GetRepoMetaRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{34} }

func (m *GetRepoMetaRequest) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type RepoMetaInfo struct {
	RepositoryID uint64 `protobuf:"varint,1,opt,name=RepositoryID" json:"RepositoryID,omitempty"`
}

func (m *RepoMetaInfo) Reset()                    { *m = RepoMetaInfo{} }
func (m *RepoMetaInfo) String() string            { return proto.CompactTextString(m) }
func (*RepoMetaInfo) ProtoMessage()               {}
func (*RepoMetaInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{35} }

func (m *RepoMetaInfo) GetRepositoryID() uint64 {
	if m != nil {
		return m.RepositoryID
	}
	return 0
}

func init() {
	proto.RegisterType((*CreateBuildRequest)(nil), "buildrepo.CreateBuildRequest")
	proto.RegisterType((*CreateBuildResponse)(nil), "buildrepo.CreateBuildResponse")
	proto.RegisterType((*UploadTokenRequest)(nil), "buildrepo.UploadTokenRequest")
	proto.RegisterType((*UploadTokenResponse)(nil), "buildrepo.UploadTokenResponse")
	proto.RegisterType((*UploadDoneRequest)(nil), "buildrepo.UploadDoneRequest")
	proto.RegisterType((*UploadDoneResponse)(nil), "buildrepo.UploadDoneResponse")
	proto.RegisterType((*RepoEntry)(nil), "buildrepo.RepoEntry")
	proto.RegisterType((*ListReposRequest)(nil), "buildrepo.ListReposRequest")
	proto.RegisterType((*ListReposResponse)(nil), "buildrepo.ListReposResponse")
	proto.RegisterType((*ListBranchesRequest)(nil), "buildrepo.ListBranchesRequest")
	proto.RegisterType((*ListBranchesResponse)(nil), "buildrepo.ListBranchesResponse")
	proto.RegisterType((*ListVersionsRequest)(nil), "buildrepo.ListVersionsRequest")
	proto.RegisterType((*ListVersionsResponse)(nil), "buildrepo.ListVersionsResponse")
	proto.RegisterType((*ListFilesRequest)(nil), "buildrepo.ListFilesRequest")
	proto.RegisterType((*ListFilesResponse)(nil), "buildrepo.ListFilesResponse")
	proto.RegisterType((*GetLatestVersionRequest)(nil), "buildrepo.GetLatestVersionRequest")
	proto.RegisterType((*GetLatestVersionResponse)(nil), "buildrepo.GetLatestVersionResponse")
	proto.RegisterType((*BuildMeta)(nil), "buildrepo.BuildMeta")
	proto.RegisterType((*GetBlockRequest)(nil), "buildrepo.GetBlockRequest")
	proto.RegisterType((*GetBlockResponse)(nil), "buildrepo.GetBlockResponse")
	proto.RegisterType((*File)(nil), "buildrepo.File")
	proto.RegisterType((*Tool)(nil), "buildrepo.Tool")
	proto.RegisterType((*ListToolsResponse)(nil), "buildrepo.ListToolsResponse")
	proto.RegisterType((*GetFileRequest)(nil), "buildrepo.GetFileRequest")
	proto.RegisterType((*FileBlock)(nil), "buildrepo.FileBlock")
	proto.RegisterType((*GetMetaRequest)(nil), "buildrepo.GetMetaRequest")
	proto.RegisterType((*GetMetaResponse)(nil), "buildrepo.GetMetaResponse")
	proto.RegisterType((*RepoDef)(nil), "buildrepo.RepoDef")
	proto.RegisterType((*BuildNumber)(nil), "buildrepo.BuildNumber")
	proto.RegisterType((*BuildDef)(nil), "buildrepo.BuildDef")
	proto.RegisterType((*BuildInfo)(nil), "buildrepo.BuildInfo")
	proto.RegisterType((*FilePattern)(nil), "buildrepo.FilePattern")
	proto.RegisterType((*FileList)(nil), "buildrepo.FileList")
	proto.RegisterType((*FileExistsInfo)(nil), "buildrepo.FileExistsInfo")
	proto.RegisterType((*GetRepoMetaRequest)(nil), "buildrepo.GetRepoMetaRequest")
	proto.RegisterType((*RepoMetaInfo)(nil), "buildrepo.RepoMetaInfo")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for BuildRepoManager service

type BuildRepoManagerClient interface {
	CreateBuild(ctx context.Context, in *CreateBuildRequest, opts ...grpc.CallOption) (*CreateBuildResponse, error)
	GetUploadToken(ctx context.Context, in *UploadTokenRequest, opts ...grpc.CallOption) (*UploadTokenResponse, error)
	UploadsComplete(ctx context.Context, in *UploadDoneRequest, opts ...grpc.CallOption) (*UploadDoneResponse, error)
	ListRepos(ctx context.Context, in *ListReposRequest, opts ...grpc.CallOption) (*ListReposResponse, error)
	ListBranches(ctx context.Context, in *ListBranchesRequest, opts ...grpc.CallOption) (*ListBranchesResponse, error)
	ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...grpc.CallOption) (*ListVersionsResponse, error)
	ListFiles(ctx context.Context, in *ListFilesRequest, opts ...grpc.CallOption) (*ListFilesResponse, error)
	ListTools(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*ListToolsResponse, error)
	GetLatestVersion(ctx context.Context, in *GetLatestVersionRequest, opts ...grpc.CallOption) (*GetLatestVersionResponse, error)
	GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error)
	GetFileMetaData(ctx context.Context, in *GetMetaRequest, opts ...grpc.CallOption) (*GetMetaResponse, error)
	GetFileAsStream(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (BuildRepoManager_GetFileAsStreamClient, error)
	PutFileAsStream(ctx context.Context, opts ...grpc.CallOption) (BuildRepoManager_PutFileAsStreamClient, error)
	ReserveNextBuildNumber(ctx context.Context, in *RepoDef, opts ...grpc.CallOption) (*BuildNumber, error)
	GetBuildInfo(ctx context.Context, in *BuildDef, opts ...grpc.CallOption) (*BuildInfo, error)
	// find a file by name in any repo
	FindFiles(ctx context.Context, in *FilePattern, opts ...grpc.CallOption) (*FileList, error)
	// does file exist
	DoesFileExist(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (*FileExistsInfo, error)
	// get some metadata about an artefact (which this is, it is not a repository)
	GetRepositoryMeta(ctx context.Context, in *GetRepoMetaRequest, opts ...grpc.CallOption) (*RepoMetaInfo, error)
	// unfail the diskscanner (it goes into fail mode if 100% of syncs fail for too long)
	UnfailDiskScanner(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error)
}

type buildRepoManagerClient struct {
	cc *grpc.ClientConn
}

func NewBuildRepoManagerClient(cc *grpc.ClientConn) BuildRepoManagerClient {
	return &buildRepoManagerClient{cc}
}

func (c *buildRepoManagerClient) CreateBuild(ctx context.Context, in *CreateBuildRequest, opts ...grpc.CallOption) (*CreateBuildResponse, error) {
	out := new(CreateBuildResponse)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/CreateBuild", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) GetUploadToken(ctx context.Context, in *UploadTokenRequest, opts ...grpc.CallOption) (*UploadTokenResponse, error) {
	out := new(UploadTokenResponse)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/GetUploadToken", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) UploadsComplete(ctx context.Context, in *UploadDoneRequest, opts ...grpc.CallOption) (*UploadDoneResponse, error) {
	out := new(UploadDoneResponse)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/UploadsComplete", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) ListRepos(ctx context.Context, in *ListReposRequest, opts ...grpc.CallOption) (*ListReposResponse, error) {
	out := new(ListReposResponse)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/ListRepos", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) ListBranches(ctx context.Context, in *ListBranchesRequest, opts ...grpc.CallOption) (*ListBranchesResponse, error) {
	out := new(ListBranchesResponse)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/ListBranches", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) ListVersions(ctx context.Context, in *ListVersionsRequest, opts ...grpc.CallOption) (*ListVersionsResponse, error) {
	out := new(ListVersionsResponse)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/ListVersions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) ListFiles(ctx context.Context, in *ListFilesRequest, opts ...grpc.CallOption) (*ListFilesResponse, error) {
	out := new(ListFilesResponse)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/ListFiles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) ListTools(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*ListToolsResponse, error) {
	out := new(ListToolsResponse)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/ListTools", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) GetLatestVersion(ctx context.Context, in *GetLatestVersionRequest, opts ...grpc.CallOption) (*GetLatestVersionResponse, error) {
	out := new(GetLatestVersionResponse)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/GetLatestVersion", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) GetBlock(ctx context.Context, in *GetBlockRequest, opts ...grpc.CallOption) (*GetBlockResponse, error) {
	out := new(GetBlockResponse)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/GetBlock", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) GetFileMetaData(ctx context.Context, in *GetMetaRequest, opts ...grpc.CallOption) (*GetMetaResponse, error) {
	out := new(GetMetaResponse)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/GetFileMetaData", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) GetFileAsStream(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (BuildRepoManager_GetFileAsStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BuildRepoManager_serviceDesc.Streams[0], c.cc, "/buildrepo.BuildRepoManager/GetFileAsStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &buildRepoManagerGetFileAsStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type BuildRepoManager_GetFileAsStreamClient interface {
	Recv() (*FileBlock, error)
	grpc.ClientStream
}

type buildRepoManagerGetFileAsStreamClient struct {
	grpc.ClientStream
}

func (x *buildRepoManagerGetFileAsStreamClient) Recv() (*FileBlock, error) {
	m := new(FileBlock)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *buildRepoManagerClient) PutFileAsStream(ctx context.Context, opts ...grpc.CallOption) (BuildRepoManager_PutFileAsStreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_BuildRepoManager_serviceDesc.Streams[1], c.cc, "/buildrepo.BuildRepoManager/PutFileAsStream", opts...)
	if err != nil {
		return nil, err
	}
	x := &buildRepoManagerPutFileAsStreamClient{stream}
	return x, nil
}

type BuildRepoManager_PutFileAsStreamClient interface {
	Send(*FileBlock) error
	CloseAndRecv() (*common.Void, error)
	grpc.ClientStream
}

type buildRepoManagerPutFileAsStreamClient struct {
	grpc.ClientStream
}

func (x *buildRepoManagerPutFileAsStreamClient) Send(m *FileBlock) error {
	return x.ClientStream.SendMsg(m)
}

func (x *buildRepoManagerPutFileAsStreamClient) CloseAndRecv() (*common.Void, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(common.Void)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *buildRepoManagerClient) ReserveNextBuildNumber(ctx context.Context, in *RepoDef, opts ...grpc.CallOption) (*BuildNumber, error) {
	out := new(BuildNumber)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/ReserveNextBuildNumber", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) GetBuildInfo(ctx context.Context, in *BuildDef, opts ...grpc.CallOption) (*BuildInfo, error) {
	out := new(BuildInfo)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/GetBuildInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) FindFiles(ctx context.Context, in *FilePattern, opts ...grpc.CallOption) (*FileList, error) {
	out := new(FileList)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/FindFiles", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) DoesFileExist(ctx context.Context, in *GetFileRequest, opts ...grpc.CallOption) (*FileExistsInfo, error) {
	out := new(FileExistsInfo)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/DoesFileExist", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) GetRepositoryMeta(ctx context.Context, in *GetRepoMetaRequest, opts ...grpc.CallOption) (*RepoMetaInfo, error) {
	out := new(RepoMetaInfo)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/GetRepositoryMeta", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *buildRepoManagerClient) UnfailDiskScanner(ctx context.Context, in *common.Void, opts ...grpc.CallOption) (*common.Void, error) {
	out := new(common.Void)
	err := grpc.Invoke(ctx, "/buildrepo.BuildRepoManager/UnfailDiskScanner", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for BuildRepoManager service

type BuildRepoManagerServer interface {
	CreateBuild(context.Context, *CreateBuildRequest) (*CreateBuildResponse, error)
	GetUploadToken(context.Context, *UploadTokenRequest) (*UploadTokenResponse, error)
	UploadsComplete(context.Context, *UploadDoneRequest) (*UploadDoneResponse, error)
	ListRepos(context.Context, *ListReposRequest) (*ListReposResponse, error)
	ListBranches(context.Context, *ListBranchesRequest) (*ListBranchesResponse, error)
	ListVersions(context.Context, *ListVersionsRequest) (*ListVersionsResponse, error)
	ListFiles(context.Context, *ListFilesRequest) (*ListFilesResponse, error)
	ListTools(context.Context, *common.Void) (*ListToolsResponse, error)
	GetLatestVersion(context.Context, *GetLatestVersionRequest) (*GetLatestVersionResponse, error)
	GetBlock(context.Context, *GetBlockRequest) (*GetBlockResponse, error)
	GetFileMetaData(context.Context, *GetMetaRequest) (*GetMetaResponse, error)
	GetFileAsStream(*GetFileRequest, BuildRepoManager_GetFileAsStreamServer) error
	PutFileAsStream(BuildRepoManager_PutFileAsStreamServer) error
	ReserveNextBuildNumber(context.Context, *RepoDef) (*BuildNumber, error)
	GetBuildInfo(context.Context, *BuildDef) (*BuildInfo, error)
	// find a file by name in any repo
	FindFiles(context.Context, *FilePattern) (*FileList, error)
	// does file exist
	DoesFileExist(context.Context, *GetFileRequest) (*FileExistsInfo, error)
	// get some metadata about an artefact (which this is, it is not a repository)
	GetRepositoryMeta(context.Context, *GetRepoMetaRequest) (*RepoMetaInfo, error)
	// unfail the diskscanner (it goes into fail mode if 100% of syncs fail for too long)
	UnfailDiskScanner(context.Context, *common.Void) (*common.Void, error)
}

func RegisterBuildRepoManagerServer(s *grpc.Server, srv BuildRepoManagerServer) {
	s.RegisterService(&_BuildRepoManager_serviceDesc, srv)
}

func _BuildRepoManager_CreateBuild_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateBuildRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).CreateBuild(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/CreateBuild",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).CreateBuild(ctx, req.(*CreateBuildRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_GetUploadToken_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadTokenRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).GetUploadToken(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/GetUploadToken",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).GetUploadToken(ctx, req.(*UploadTokenRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_UploadsComplete_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadDoneRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).UploadsComplete(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/UploadsComplete",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).UploadsComplete(ctx, req.(*UploadDoneRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_ListRepos_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListReposRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).ListRepos(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/ListRepos",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).ListRepos(ctx, req.(*ListReposRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_ListBranches_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListBranchesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).ListBranches(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/ListBranches",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).ListBranches(ctx, req.(*ListBranchesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_ListVersions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListVersionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).ListVersions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/ListVersions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).ListVersions(ctx, req.(*ListVersionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_ListFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).ListFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/ListFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).ListFiles(ctx, req.(*ListFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_ListTools_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).ListTools(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/ListTools",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).ListTools(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_GetLatestVersion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetLatestVersionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).GetLatestVersion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/GetLatestVersion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).GetLatestVersion(ctx, req.(*GetLatestVersionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_GetBlock_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetBlockRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).GetBlock(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/GetBlock",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).GetBlock(ctx, req.(*GetBlockRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_GetFileMetaData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).GetFileMetaData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/GetFileMetaData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).GetFileMetaData(ctx, req.(*GetMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_GetFileAsStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(GetFileRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(BuildRepoManagerServer).GetFileAsStream(m, &buildRepoManagerGetFileAsStreamServer{stream})
}

type BuildRepoManager_GetFileAsStreamServer interface {
	Send(*FileBlock) error
	grpc.ServerStream
}

type buildRepoManagerGetFileAsStreamServer struct {
	grpc.ServerStream
}

func (x *buildRepoManagerGetFileAsStreamServer) Send(m *FileBlock) error {
	return x.ServerStream.SendMsg(m)
}

func _BuildRepoManager_PutFileAsStream_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(BuildRepoManagerServer).PutFileAsStream(&buildRepoManagerPutFileAsStreamServer{stream})
}

type BuildRepoManager_PutFileAsStreamServer interface {
	SendAndClose(*common.Void) error
	Recv() (*FileBlock, error)
	grpc.ServerStream
}

type buildRepoManagerPutFileAsStreamServer struct {
	grpc.ServerStream
}

func (x *buildRepoManagerPutFileAsStreamServer) SendAndClose(m *common.Void) error {
	return x.ServerStream.SendMsg(m)
}

func (x *buildRepoManagerPutFileAsStreamServer) Recv() (*FileBlock, error) {
	m := new(FileBlock)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _BuildRepoManager_ReserveNextBuildNumber_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RepoDef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).ReserveNextBuildNumber(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/ReserveNextBuildNumber",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).ReserveNextBuildNumber(ctx, req.(*RepoDef))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_GetBuildInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BuildDef)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).GetBuildInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/GetBuildInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).GetBuildInfo(ctx, req.(*BuildDef))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_FindFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FilePattern)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).FindFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/FindFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).FindFiles(ctx, req.(*FilePattern))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_DoesFileExist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).DoesFileExist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/DoesFileExist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).DoesFileExist(ctx, req.(*GetFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_GetRepositoryMeta_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetRepoMetaRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).GetRepositoryMeta(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/GetRepositoryMeta",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).GetRepositoryMeta(ctx, req.(*GetRepoMetaRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _BuildRepoManager_UnfailDiskScanner_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(common.Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(BuildRepoManagerServer).UnfailDiskScanner(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/buildrepo.BuildRepoManager/UnfailDiskScanner",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(BuildRepoManagerServer).UnfailDiskScanner(ctx, req.(*common.Void))
	}
	return interceptor(ctx, in, info, handler)
}

var _BuildRepoManager_serviceDesc = grpc.ServiceDesc{
	ServiceName: "buildrepo.BuildRepoManager",
	HandlerType: (*BuildRepoManagerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateBuild",
			Handler:    _BuildRepoManager_CreateBuild_Handler,
		},
		{
			MethodName: "GetUploadToken",
			Handler:    _BuildRepoManager_GetUploadToken_Handler,
		},
		{
			MethodName: "UploadsComplete",
			Handler:    _BuildRepoManager_UploadsComplete_Handler,
		},
		{
			MethodName: "ListRepos",
			Handler:    _BuildRepoManager_ListRepos_Handler,
		},
		{
			MethodName: "ListBranches",
			Handler:    _BuildRepoManager_ListBranches_Handler,
		},
		{
			MethodName: "ListVersions",
			Handler:    _BuildRepoManager_ListVersions_Handler,
		},
		{
			MethodName: "ListFiles",
			Handler:    _BuildRepoManager_ListFiles_Handler,
		},
		{
			MethodName: "ListTools",
			Handler:    _BuildRepoManager_ListTools_Handler,
		},
		{
			MethodName: "GetLatestVersion",
			Handler:    _BuildRepoManager_GetLatestVersion_Handler,
		},
		{
			MethodName: "GetBlock",
			Handler:    _BuildRepoManager_GetBlock_Handler,
		},
		{
			MethodName: "GetFileMetaData",
			Handler:    _BuildRepoManager_GetFileMetaData_Handler,
		},
		{
			MethodName: "ReserveNextBuildNumber",
			Handler:    _BuildRepoManager_ReserveNextBuildNumber_Handler,
		},
		{
			MethodName: "GetBuildInfo",
			Handler:    _BuildRepoManager_GetBuildInfo_Handler,
		},
		{
			MethodName: "FindFiles",
			Handler:    _BuildRepoManager_FindFiles_Handler,
		},
		{
			MethodName: "DoesFileExist",
			Handler:    _BuildRepoManager_DoesFileExist_Handler,
		},
		{
			MethodName: "GetRepositoryMeta",
			Handler:    _BuildRepoManager_GetRepositoryMeta_Handler,
		},
		{
			MethodName: "UnfailDiskScanner",
			Handler:    _BuildRepoManager_UnfailDiskScanner_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "GetFileAsStream",
			Handler:       _BuildRepoManager_GetFileAsStream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "PutFileAsStream",
			Handler:       _BuildRepoManager_PutFileAsStream_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "golang.conradwood.net/apis/buildrepo/buildrepo.proto",
}

func init() {
	proto.RegisterFile("golang.conradwood.net/apis/buildrepo/buildrepo.proto", fileDescriptor0)
}

var fileDescriptor0 = []byte{
	// 1338 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xb4, 0x58, 0x5f, 0x53, 0x1b, 0x37,
	0x10, 0x1f, 0x83, 0x03, 0x78, 0x0d, 0x01, 0x04, 0x43, 0x9c, 0x0b, 0x49, 0x19, 0x25, 0x6d, 0x99,
	0xe9, 0x8c, 0xd3, 0xd2, 0x66, 0xd2, 0xf4, 0x2d, 0x70, 0x40, 0x49, 0x03, 0x49, 0x8f, 0x90, 0x97,
	0xf6, 0x45, 0xd8, 0x32, 0xb9, 0xc9, 0xf9, 0xe4, 0x9e, 0x44, 0xfe, 0xf4, 0x03, 0x74, 0xa6, 0xef,
	0xfd, 0x08, 0xfd, 0x4e, 0xfd, 0x3a, 0x1d, 0xad, 0x74, 0x77, 0xd2, 0x9d, 0xcd, 0x10, 0x68, 0x5f,
	0x40, 0xda, 0xff, 0xbb, 0xfa, 0x69, 0xb5, 0x3e, 0xf8, 0xee, 0x4c, 0x24, 0x2c, 0x3d, 0xeb, 0xf6,
	0x44, 0x9a, 0xb1, 0xfe, 0x7b, 0x21, 0xfa, 0xdd, 0x94, 0xab, 0x87, 0x6c, 0x14, 0xcb, 0x87, 0xa7,
	0xe7, 0x71, 0xd2, 0xcf, 0xf8, 0x48, 0x94, 0xab, 0xee, 0x28, 0x13, 0x4a, 0x90, 0x56, 0x41, 0x08,
	0xba, 0x17, 0x18, 0xe8, 0x89, 0xe1, 0x50, 0xa4, 0xf6, 0x9f, 0x51, 0xa5, 0x7f, 0x4c, 0x01, 0xd9,
	0xc9, 0x38, 0x53, 0x7c, 0x5b, 0xdb, 0x88, 0xf8, 0x6f, 0xe7, 0x5c, 0x2a, 0x72, 0x0f, 0x20, 0xe2,
	0x23, 0x21, 0x63, 0x25, 0xb2, 0x8f, 0x9d, 0xc6, 0x46, 0x63, 0xb3, 0x15, 0x39, 0x14, 0x12, 0xc0,
	0xdc, 0x8e, 0x18, 0x0e, 0x63, 0x75, 0x10, 0x76, 0xa6, 0x90, 0x5b, 0xec, 0xc9, 0x1a, 0xcc, 0x6c,
	0x67, 0x2c, 0xed, 0xbd, 0xe9, 0x4c, 0x23, 0xc7, 0xee, 0x48, 0x07, 0x66, 0xd1, 0xc7, 0x41, 0xd8,
	0x69, 0x6e, 0x34, 0x36, 0x9b, 0x51, 0xbe, 0x25, 0xeb, 0xd0, 0x32, 0xda, 0x87, 0xc7, 0xfb, 0x9d,
	0x1b, 0xa8, 0x54, 0x12, 0x34, 0xf7, 0x44, 0xf2, 0x6c, 0x77, 0xc8, 0xe2, 0xa4, 0x33, 0x63, 0xb8,
	0x05, 0x81, 0x50, 0x98, 0x2f, 0xe3, 0x3a, 0x08, 0x3b, 0xb3, 0x68, 0xda, 0xa3, 0x69, 0x99, 0xa7,
	0x99, 0xe2, 0x03, 0xd6, 0x53, 0x47, 0x6c, 0xc8, 0x3b, 0x73, 0x68, 0xc4, 0xa3, 0xd1, 0x27, 0xb0,
	0xe2, 0xd5, 0x41, 0x8e, 0x44, 0x2a, 0xb9, 0x56, 0x45, 0xc2, 0xb1, 0x12, 0x19, 0x8f, 0xfb, 0xb6,
	0x14, 0x1e, 0x8d, 0x66, 0x40, 0x4e, 0x46, 0x89, 0x60, 0xfd, 0x57, 0xe2, 0x2d, 0x4f, 0xf3, 0x12,
	0x5e, 0x42, 0x53, 0x97, 0x71, 0x2f, 0x4e, 0x78, 0xaa, 0x83, 0xb2, 0x65, 0xcc, 0xf7, 0x7e, 0xda,
	0xd3, 0x95, 0xb4, 0xe9, 0x57, 0xb0, 0xe2, 0xf9, 0xb4, 0xe1, 0xae, 0xc2, 0x0d, 0x24, 0x58, 0x6f,
	0x66, 0x43, 0x1f, 0xc3, 0xb2, 0x11, 0x0e, 0x45, 0xca, 0x3f, 0x21, 0x3e, 0xfa, 0x2c, 0xcf, 0xcc,
	0x28, 0x5a, 0x27, 0x6b, 0x30, 0xb3, 0x93, 0x08, 0xc9, 0x8d, 0xce, 0x5c, 0x64, 0x77, 0x18, 0x31,
	0x4a, 0xc7, 0xe9, 0x19, 0xa6, 0xb3, 0x10, 0x95, 0x04, 0xfa, 0x77, 0x03, 0x5a, 0xfa, 0x54, 0x76,
	0x53, 0x95, 0x7d, 0x24, 0x04, 0x9a, 0x78, 0x14, 0xc6, 0x2b, 0xae, 0x35, 0xed, 0xd5, 0xc7, 0x91,
	0xa9, 0xc4, 0x8d, 0x08, 0xd7, 0x64, 0x09, 0xa6, 0xc3, 0x38, 0xb3, 0xf9, 0xeb, 0xa5, 0xf6, 0x1e,
	0x8a, 0x21, 0x8b, 0x53, 0x44, 0x51, 0x2b, 0xb2, 0x3b, 0xb2, 0x0b, 0xed, 0xe7, 0x4c, 0x71, 0xa9,
	0x30, 0x03, 0x84, 0x51, 0x7b, 0xeb, 0x7e, 0xb7, 0xbc, 0x2b, 0xfb, 0x5c, 0x19, 0x81, 0xd7, 0x3c,
	0x93, 0xb1, 0x28, 0x8a, 0x16, 0xb9, 0x7a, 0x94, 0xc0, 0xd2, 0xf3, 0x58, 0x2a, 0xc4, 0x8f, 0x2d,
	0x15, 0xdd, 0x81, 0x65, 0x87, 0x66, 0xab, 0xd0, 0x85, 0x59, 0x9d, 0x4a, 0xcc, 0x65, 0xa7, 0xb1,
	0x31, 0xbd, 0xd9, 0xde, 0x5a, 0x75, 0x7c, 0x15, 0x89, 0x46, 0xb9, 0x10, 0x7d, 0x04, 0x2b, 0xda,
	0x88, 0xb9, 0x0c, 0x5c, 0x5e, 0xf2, 0xa6, 0xd1, 0x3d, 0x58, 0xf5, 0xd5, 0xae, 0xe8, 0xfe, 0xd0,
	0xb8, 0xb7, 0xb9, 0x5f, 0xd6, 0xbd, 0x73, 0x99, 0xa7, 0xdc, 0xcb, 0x9c, 0x87, 0x55, 0x9a, 0xbb,
	0x62, 0x58, 0x7f, 0x35, 0x4c, 0xbd, 0x35, 0xec, 0xaf, 0x1b, 0x94, 0xdb, 0x61, 0xa6, 0xfd, 0x0e,
	0x63, 0x61, 0xd4, 0x2c, 0x61, 0xb4, 0xae, 0xd1, 0xd8, 0x3b, 0xcf, 0x64, 0xfc, 0x8e, 0x23, 0x58,
	0xe6, 0xa2, 0x92, 0x90, 0x9f, 0xb8, 0x8d, 0xea, 0x8a, 0xb9, 0xfd, 0x0c, 0xb7, 0xea, 0x98, 0xbb,
	0x5e, 0xd9, 0xdf, 0x40, 0x67, 0x12, 0x8c, 0xdd, 0xec, 0x1b, 0x7e, 0xf6, 0x5b, 0xd0, 0xc2, 0xe5,
	0x21, 0x57, 0x0c, 0x0d, 0xfa, 0xa1, 0x17, 0xbc, 0xa8, 0x14, 0xa3, 0x3d, 0x47, 0xa7, 0xd6, 0x64,
	0x1b, 0x63, 0x9a, 0xec, 0x15, 0x9e, 0x04, 0x7a, 0x0a, 0x8b, 0xfb, 0x5c, 0x6d, 0x27, 0xa2, 0xf7,
	0x36, 0xaf, 0xcc, 0x7d, 0x68, 0x0e, 0xe2, 0xc4, 0x34, 0x86, 0xf6, 0xd6, 0xa2, 0x13, 0xa6, 0x3e,
	0x8c, 0x08, 0x99, 0xda, 0xde, 0x8b, 0xc1, 0x40, 0x72, 0x85, 0x9e, 0x9a, 0x91, 0xdd, 0xe9, 0x0e,
	0x72, 0x1c, 0xff, 0xce, 0xd1, 0xcb, 0x42, 0x84, 0x6b, 0xfa, 0x1e, 0x96, 0x4a, 0x1f, 0xb6, 0x54,
	0xff, 0xb5, 0x13, 0x4d, 0x0b, 0x99, 0x62, 0x08, 0xb0, 0xf9, 0x08, 0xd7, 0x54, 0x41, 0x53, 0x5b,
	0xfb, 0x1f, 0xd0, 0xec, 0x3e, 0x1b, 0x4d, 0xff, 0xd9, 0xa0, 0xdb, 0xd0, 0x7c, 0x25, 0x44, 0x72,
	0x99, 0x17, 0x7c, 0xd2, 0xd3, 0x43, 0x7f, 0x30, 0xe8, 0xd7, 0x76, 0x4a, 0xf4, 0x7f, 0xae, 0x9f,
	0x16, 0x91, 0xe4, 0xd8, 0x77, 0x8b, 0xa6, 0xe9, 0x91, 0xe1, 0xd2, 0x63, 0xb8, 0xb9, 0xcf, 0xf1,
	0xe2, 0x7c, 0xd2, 0x89, 0xae, 0x43, 0x0b, 0x8f, 0x48, 0xea, 0xca, 0xda, 0xb7, 0xa3, 0x20, 0xd0,
	0x13, 0x68, 0x69, 0x59, 0x24, 0x14, 0xf5, 0x37, 0x20, 0xf4, 0xeb, 0x3f, 0x55, 0xd6, 0x9f, 0x6c,
	0x40, 0xdb, 0x79, 0x22, 0x2d, 0xf2, 0x5c, 0x12, 0x7d, 0x84, 0xb1, 0x22, 0xf2, 0xcb, 0x58, 0xf7,
	0x2e, 0x8a, 0x55, 0xff, 0xa5, 0xcf, 0x10, 0xb5, 0x46, 0xed, 0x53, 0x00, 0x95, 0x07, 0x3e, 0x55,
	0x06, 0x4e, 0x9f, 0xc2, 0xac, 0x3e, 0x94, 0x90, 0x0f, 0xae, 0xdc, 0x13, 0xbe, 0x84, 0x36, 0x02,
	0xe3, 0xe8, 0x7c, 0x78, 0xca, 0xb3, 0xc9, 0x6d, 0x80, 0xfe, 0x0a, 0x73, 0xb8, 0xbc, 0x86, 0xb3,
	0xc9, 0xa0, 0xa4, 0x7f, 0x36, 0x6c, 0xc7, 0x38, 0x48, 0x07, 0xc2, 0xeb, 0x06, 0x8d, 0x4a, 0x37,
	0x78, 0x00, 0x0b, 0x76, 0xba, 0xe3, 0x52, 0xb2, 0xb3, 0x1c, 0x7f, 0x3e, 0xf1, 0xe2, 0xf9, 0x07,
	0xf1, 0x82, 0xb9, 0x30, 0x65, 0xee, 0xc0, 0x42, 0x54, 0x12, 0x74, 0x49, 0x74, 0xdd, 0x5f, 0x32,
	0xa5, 0x78, 0x96, 0xea, 0xa0, 0xed, 0xd2, 0xc6, 0x92, 0x6f, 0xe9, 0x37, 0xe6, 0x16, 0x68, 0xb4,
	0x6b, 0x80, 0x63, 0xbf, 0x1f, 0x03, 0x70, 0x3c, 0x44, 0xc3, 0xa5, 0x9b, 0x70, 0x53, 0x2f, 0x76,
	0x3f, 0xc4, 0x52, 0x49, 0xcc, 0x75, 0x0d, 0x66, 0xcc, 0x2e, 0x9f, 0x87, 0xcc, 0x8e, 0x6e, 0x02,
	0xd9, 0xe7, 0x38, 0x35, 0xb8, 0x10, 0x23, 0xd0, 0x7c, 0xc9, 0xd4, 0x9b, 0x7c, 0xf2, 0xd1, 0x6b,
	0xba, 0x65, 0xfa, 0xab, 0x16, 0x43, 0x8b, 0x97, 0xe8, 0xb7, 0x5b, 0xff, 0x00, 0x2c, 0xd9, 0x59,
	0x75, 0x24, 0x0e, 0x59, 0xca, 0xce, 0x78, 0x46, 0x9e, 0x43, 0xdb, 0x99, 0x62, 0xc9, 0x5d, 0x27,
	0x87, 0xfa, 0x94, 0x1f, 0xdc, 0x9b, 0xc4, 0xb6, 0xa8, 0x7e, 0x81, 0xf7, 0xc3, 0xb9, 0x31, 0x9e,
	0xc1, 0xfa, 0xcc, 0xeb, 0x19, 0x1c, 0x37, 0x9e, 0x1e, 0xc1, 0xa2, 0x21, 0xcb, 0x1d, 0x31, 0x1c,
	0x25, 0x5c, 0x71, 0xb2, 0x5e, 0x53, 0x71, 0x86, 0xd4, 0xe0, 0xee, 0x04, 0xae, 0xb5, 0xb7, 0x07,
	0xad, 0x62, 0x30, 0x23, 0x77, 0x1c, 0xd9, 0xea, 0x08, 0x17, 0xac, 0x8f, 0x67, 0x16, 0x89, 0xce,
	0xbb, 0x43, 0x16, 0xb9, 0x57, 0x91, 0xae, 0x0c, 0x6d, 0xc1, 0x67, 0x13, 0xf9, 0xbe, 0xc1, 0x7c,
	0x3c, 0xaa, 0x19, 0xac, 0x8c, 0x61, 0x35, 0x83, 0xb5, 0xb9, 0xca, 0x66, 0x8a, 0x10, 0xac, 0x65,
	0xea, 0x0e, 0x4f, 0xb5, 0x4c, 0xfd, 0x19, 0xe6, 0xb1, 0xb1, 0x83, 0xbd, 0x9a, 0xcc, 0x77, 0xed,
	0x6f, 0xc1, 0xd7, 0x22, 0xee, 0xd7, 0x14, 0xfd, 0xf6, 0xff, 0x0b, 0x3e, 0xa3, 0xde, 0xe4, 0x41,
	0xe8, 0x85, 0xd3, 0xb5, 0x09, 0xe7, 0x32, 0x13, 0x38, 0xd9, 0x81, 0xb9, 0xfc, 0x8d, 0x26, 0x81,
	0xaf, 0xe0, 0x0e, 0x07, 0xc1, 0x9d, 0xb1, 0x3c, 0x6b, 0xe4, 0x47, 0x6c, 0xcb, 0x3a, 0x5d, 0x7d,
	0x8f, 0xf0, 0x09, 0xb8, 0xed, 0xcb, 0x3b, 0xd7, 0x30, 0x08, 0xc6, 0xb1, 0xac, 0xa5, 0xb0, 0xb0,
	0xf4, 0x54, 0x1e, 0xab, 0x8c, 0xb3, 0x61, 0xd5, 0x92, 0xf3, 0xbe, 0x05, 0xab, 0x95, 0x46, 0x81,
	0x51, 0x7d, 0xdd, 0x20, 0x8f, 0x61, 0xf1, 0xe5, 0xb9, 0x6f, 0x65, 0xac, 0x68, 0xe0, 0x1d, 0xc3,
	0x66, 0x83, 0x84, 0xb0, 0x16, 0x71, 0xc9, 0xb3, 0x77, 0xfc, 0x88, 0x7f, 0x50, 0x6e, 0x6f, 0x27,
	0x95, 0x81, 0x33, 0xe4, 0x83, 0x60, 0xad, 0x3a, 0xc9, 0x59, 0xd9, 0x27, 0x30, 0xaf, 0x4b, 0x54,
	0x74, 0xe4, 0x95, 0xaa, 0x9c, 0x56, 0xae, 0x8d, 0x81, 0x28, 0xfa, 0xbd, 0x7e, 0x6e, 0xd3, 0xbe,
	0x01, 0xdb, 0x5a, 0x25, 0x66, 0xdb, 0x3a, 0x83, 0x95, 0x0a, 0x1d, 0x7b, 0xe8, 0x2e, 0x2c, 0x84,
	0x82, 0xcb, 0xa2, 0x41, 0x5e, 0x54, 0xb7, 0xdb, 0x15, 0x03, 0x4e, 0x47, 0xfd, 0x09, 0x96, 0x6d,
	0xe7, 0x34, 0xed, 0x0e, 0x87, 0xd0, 0xbb, 0xbe, 0xa9, 0x4a, 0x5f, 0x0d, 0x6e, 0x55, 0x6a, 0x53,
	0x34, 0xd3, 0x87, 0xb0, 0x7c, 0x92, 0x0e, 0x58, 0x9c, 0x84, 0xb1, 0x7c, 0x7b, 0xdc, 0x63, 0x69,
	0xca, 0xb3, 0x0a, 0xf4, 0xbd, 0xdd, 0xf6, 0x17, 0xf0, 0x20, 0xe5, 0xca, 0xfd, 0x84, 0x62, 0x3f,
	0xaa, 0xb0, 0x51, 0x2c, 0x4b, 0x2f, 0xa7, 0x33, 0xf8, 0x09, 0xe5, 0xdb, 0x7f, 0x03, 0x00, 0x00,
	0xff, 0xff, 0x8a, 0xa8, 0xd6, 0x30, 0xb5, 0x11, 0x00, 0x00,
}
